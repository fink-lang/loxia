{add, any} = import '../context.fnk'
{transform, ir_fn} = import '../transform.fnk'
{unique_name} = import '../context.fnk'
{transform_dl} = import '../assignment/init.fnk'



cc = fn ret_id, res_id, {loc}:
  ret = ir_fn 'cc', [ret_id, res_id], {loc}
  [ret, []]



fnc = fn args_id, ret_id, res_id, body, {loc}:
  ret = cc ret_id, res_id, {loc}
  ir_fn 'fn', [[args_id, ret_id], [...body, ret]], {loc}



transform_exprs = fn [expr=false, ...rest], ctx, out, last_id:
  match expr:
    false:
      [out, last_id, ctx]
    else:
      [foo, id, next_ctx] = transform expr, 'result', ctx
      transform_exprs rest, next_ctx, [...out, ...foo], id




transform_args = fn {args: exprs, loc}, ctx:
  [args_id, next_ctx] = unique_name 'args', {loc}, ctx
  [args, , end_ctx] = transform_dl exprs, args_id, next_ctx
  [args, args_id, end_ctx]



transform_func = fn expr, res_id, {scopes=[], ...ctx}:
  args_ctx = {...ctx, scopes: [{}, ...scopes]}
  [args, args_id, ret_ctx] = transform_args expr, args_ctx
  [ret_id, body_ctx] = unique_name 'ret', expr, ret_ctx
  [body, fn_res_id, end_ctx] = transform_exprs expr.exprs, body_ctx, []

  fun = fnc args_id, ret_id, fn_res_id, [...args, ...body], expr
  [[[fun, [res_id]]], {...end_ctx, scopes}]



add_func = fn ctx:
  pipe ctx:
    add any, 'fn', transform_func

{starts_with} = import '@fink/std-lib/str.fnk'
{add, any, unique_name} = import '../context.fnk'
{transform, ir_fn} = import '../transform.fnk'
{bind} = import '../assignment/init.fnk'
{str} = import '../literals/string.fnk'
{rec_empty, rec_s} = import '../literals/record.fnk'
{lst, lst_a_x} = import '../literals/list.fnk'
{transform_import, imp} = import './import.fnk'



mod = fn exp_id, dirs_id, res_id, {loc}:
  expr = ir_fn 'mod', [exp_id, dirs_id], {loc}
  [[expr, [res_id]]]



get_key_val = fn expr, ctx:
  [key, key_id, val_id, next_ctx] = match expr:
    {left.type: 'ident', right: false}:
      [val_id, key_ctx] = bind expr.left, ctx
      [key, key_id, next_ctx] = str expr.left.value, 'key', expr.left, key_ctx
      [key, key_id, val_id, next_ctx]

    {left.type: 'ident', right.type: 'ident'}:
      [val_id, key_ctx] = bind expr.right, ctx
      [key, key_id, next_ctx] = str expr.left.value, 'key', expr.left, key_ctx
      [key, key_id, val_id, next_ctx]

    {right.type: 'ident'}:
      [val_id, key_ctx] = bind expr.right, ctx
      [key, key_id, next_ctx] = transform expr.left, 'key', key_ctx
      [key, key_id, val_id, next_ctx]

    {left.type: 'ident'}:
      # TODO: loc?
      [val_id, key_ctx] = unique_name 'val', expr, ctx
      [key, key_id, next_ctx] = str expr.left.value, 'key', expr.left, key_ctx
      [key, key_id, val_id, next_ctx]

    else:
      # TODO: loc?
      [val_id, key_ctx] = unique_name 'val', expr, ctx
      [key, key_id, next_ctx] = transform expr.left, 'key', key_ctx
      [key, key_id, val_id, next_ctx]

  [key, key_id, val_id, next_ctx]



transform_imp_rec = fn [expr=false, ...exprs], uri_id, ctx, out=[]:
  match expr:
    false:
      [out, ctx]

    {type: 'rec:kv'}:
      [key, key_id, val_id, imp_ctx] = get_key_val expr, ctx
      [imps, , next_ctx] = imp uri_id, key_id, val_id, expr, imp_ctx
      transform_imp_rec exprs, uri_id, next_ctx, [...out, ...key, ...imps]



transform_imp = fn node, uri_id, ctx:
  match node:
    {type: 'rec'}:
      transform_imp_rec node.exprs, uri_id, ctx

    {type: 'ident'}:
      [val_id, imp_ctx] = bind node, ctx
      [imps, , next_ctx] = imp uri_id, false, val_id, node, imp_ctx
      [imps, next_ctx]



ident_to_key = fn {value: name, loc}, ctx:
  str name, 'key', {loc}, ctx



add_export = fn exp_id, expr, ctx:
  [val, , key_ctx] = transform expr, 'ares', ctx
  [..., [ , [val_id]]] = val

  [key, key_id, exp_ctx] = ident_to_key expr.left, key_ctx

  [next_exp_id, next_ctx] = unique_name 'exports', expr, exp_ctx
  exp = rec_s exp_id, key_id, val_id, next_exp_id, expr

  [[...val, ...key, [exp, [next_exp_id]]], next_exp_id, next_ctx]



transform_exprs = fn [expr=false, ...rest], exp_id, ctx, out:
  match expr:
    false:
      [out, exp_id, ctx]

    {right.op: 'import'}:
      [uri, uri_id, next_ctx] = transform expr.right.right, 'uri', ctx
      [imps, end_ctx] = transform_imp expr.left, uri_id, next_ctx
      transform_exprs rest, exp_id, end_ctx, [...out, ...uri, ...imps]

    {op: 'import'}:
      [uri, uri_id, imp_ctx] = transform expr.right, 'uri', ctx
      [imps, , next_ctx] = imp uri_id, false, false, expr, imp_ctx
      transform_exprs rest, exp_id, next_ctx, [...out, ...uri, ...imps]

    {op: '=', left: {type: 'ident'}}:
      [exprs, next_exp_id, next_ctx] = add_export exp_id, expr, ctx
      transform_exprs rest, next_exp_id, next_ctx, [...out, ...exprs]

    else:
      [foo, , next_ctx] = transform expr, 'mex', ctx
      transform_exprs rest, exp_id, next_ctx, [...out, ...foo]



transform_directives = fn expr, ctx:
  # TODO: directives should be handled as separate AST node

  [drctvs, dirs_id, next_ctx] = lst 'drctvs', expr, ctx

  {exprs: [{comments}]} = expr

  match comments:
    {leading: [{op: '#', loc: {start: {line: 1}}, value: starts_with ?, '!'}]}:
      [{value: shbang}] = comments.leading

      [shb, sh_id, d_ctx] = str '#${shbang}', 'shbng', expr, next_ctx
      [next_drctvs, lst_id, end_ctx] = lst_a_x dirs_id, sh_id, 'drctvs', expr, d_ctx
      [[...drctvs, ...shb, ...next_drctvs], lst_id, end_ctx]
    else:
      [drctvs, dirs_id, next_ctx]



transform_module = fn expr, result, ctx:
  [exp_id, dirs_ctx] = unique_name 'exports', expr, ctx
  [directives, dirs_id, exprs_ctx] = transform_directives expr, dirs_ctx
  [block, last_exp_id, next_ctx] = transform_exprs expr.exprs, exp_id, exprs_ctx, []

  out = list:
    [(rec_empty expr.loc, exp_id), [exp_id]]
    ...block
    ...directives
    ...mod last_exp_id, dirs_id, result, expr

  [out, next_ctx]



add_module = fn ctx:
  pipe ctx:
    add 'module', any, transform_module
    add 'import', any, transform_import


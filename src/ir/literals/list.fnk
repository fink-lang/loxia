{reverse} = import '@fink/std-lib/iter.fnk'
{transform, ir_fn} = import '../transform.fnk'
{unique_name} = import '../context.fnk'


lst_empty = fn {loc}:
  ir_fn 'lst', [], {loc}



lst = fn name, {loc}, ctx:
  [id, next_ctx] = unique_name name, {loc}, ctx
  expr = ir_fn 'lst', [], {loc}
  [[[expr, [id]]], id, next_ctx]


lst_a = fn lst_id, val_id, {loc}:
  ir_fn 'lst_a', [lst_id, val_id], {loc}


lst_a_x = fn lst_id, val_id, name_or_id, {loc}, ctx:
  [id, next_ctx] = unique_name name_or_id, {loc}, ctx
  expr = ir_fn 'lst_a', [lst_id, val_id], {loc}
  [[[expr, [id]]], id, next_ctx]


lst_c = fn lst1_id, lst2_id, {loc}:
  ir_fn 'lst_c', [lst1_id, lst2_id], {loc}



transform_item = fn expr, out_id, ctx:
  [lst_id, item_ctx] = unique_name 'lst', expr, ctx
  match expr:
    {type: 'spread'}:
      [items, items_id, next_ctx] = transform expr.right, 'items', item_ctx
      lst = lst_c lst_id, items_id, expr
      [[...items, [lst, [out_id]]], lst_id , next_ctx]

    # TODO use own transform for empty
    {type: 'empty'}:
      lst = lst_a lst_id, {i: '_', loc: expr.loc}, expr
      [[[lst, [out_id]]], lst_id, item_ctx]

    else:
      [item, item_id, next_ctx] = transform expr, 'item', item_ctx
      lst = lst_a lst_id, item_id, expr
      [[...item, [lst, [out_id]]], lst_id, next_ctx]



transform_items = fn [expr=false, ...rest], ctx, result_id, out=[]:
  match expr:
    false:
      [out, result_id, ctx]
    else:
      [item, list_id, next_ctx] = transform_item expr, result_id, ctx
      transform_items rest, next_ctx, list_id, [...item, ...out]



transform_list = fn node, result, ctx:
  exprs = reverse node.exprs
  [out, lst_id, next_ctx] = transform_items exprs, ctx, result
  lst = lst_empty node
  [[[lst, [lst_id]], ...out], next_ctx]


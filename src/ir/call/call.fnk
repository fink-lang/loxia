{is_empty} = import '@fink/std-lib/iter.fnk'

{transform, ir_fn} = import '../transform.fnk'
{unique_name} = import '../context.fnk'
{lst_empty, lst_a, lst_c} = import '../literals/list.fnk'
{lst_h} = import '../assignment/init.fnk'
{fnc} = import '../func/init.fnk'



lst_name = fn name, {loc}, ctx:
  [id, next_ctx] = unique_name name, {loc}, ctx
  lst = lst_empty {loc}
  [[[lst, [id]]], id, next_ctx]


af = fn fn_id, args_id, {loc}:
  ir_fn 'af', [fn_id, args_id], {loc}



func = fn arg_id, res, res_id, fn_id, {loc}, ctx:
  [args_id, ret_ctx] = unique_name 'args', {loc}, ctx
  [ret_id, fn_ctx] = unique_name 'ret', {loc}, ret_ctx

  first_arg = lst_h args_id, {loc}

  body = list:
    [first_arg, [arg_id]]
    ...res

  fun = fnc args_id, ret_id, res_id, body, {loc}
  [[[fun, [fn_id]]], fn_ctx]




add_arg = fn args_id, arg, arg_id, {loc}, ctx:
  [next_args_id, next_ctx] = unique_name 'cargs', {loc}, ctx
  args = lst_a args_id, arg_id, {loc}
  [[...arg, [args, [next_args_id]]], next_args_id, next_ctx]



spread_arg = fn args_id, arg, arg_id, {loc}, ctx:
  [next_args_id, next_ctx] = unique_name 'cargs', {loc}, ctx
  args = lst_c args_id, arg_id, {loc}
  [[...arg, [args, [next_args_id]]], next_args_id, next_ctx]



set_partial_ident = fn name, {loc}, ctx:
  [partial_ident, next_ctx] = unique_name name, {loc}, ctx
  [partial_ident, {...next_ctx, partial_ident}]



maybe_set_partial_ident = fn name, {loc}, {has_partial: _, partial_ident=false, ...ctx}:
  match partial_ident:
    false:
      [true, ...set_partial_ident name, {loc}, ctx]
    else:
      [false, partial_ident, {...ctx, partial_ident}]



transform_with_partial = fn expr, name, ctx:
  [foo, prtl, foo_ctx] = maybe_set_partial_ident 'prtl', expr, ctx

  [arg, arg_id, {has_partial, ...next_ctx}] = transform expr, name, foo_ctx

  match true:
    foo and has_partial:
      [fn_id, fn_ctx] = unique_name 'pfn', expr, next_ctx
      [fun, end_ctx] = func prtl, arg, arg_id, fn_id, {loc: expr.loc}, fn_ctx
      [fun, fn_id, end_ctx]
    else:
      [arg, arg_id, next_ctx]



transform_arg = fn expr, args_id, ctx:
  [arg, arg_id, {has_partial: _, ...next_ctx}] = transform_with_partial expr, 'arg', ctx
  add_arg args_id, arg, arg_id, {loc: expr.loc}, next_ctx




transform_spread_arg = fn expr, args_id, {partial_foo=false, has_partial, ...ctx}:
  [prlt, p_ctx] = match partial_foo:
    false: unique_name 'prtl', expr, ctx
    else: [partial_foo, ctx]

  foo_ctx = {...p_ctx, partial_ident: prlt}
  [arg, arg_id, {partial_ident:_, ...next_ctx}] = transform expr.right, 'sprd', foo_ctx
  spread_arg args_id, arg, arg_id, {loc: expr.loc}, {...next_ctx, has_partial, partial_foo: prlt}




transform_partial_arg = fn expr, args_id, {partial_foo=false, has_partial, partial_ident=false, ...ctx}:
  [prlt, p_ctx] = match partial_foo:
    false: unique_name 'prtl', expr, ctx
    else: [partial_foo, ctx]

  match partial_ident:
    false:
      foo_ctx = {...p_ctx, partial_ident: prlt}
      [arg, arg_id, {partial_ident: _, ...next_ctx}] = transform expr, 'arg', foo_ctx
      add_arg args_id, arg, arg_id, {loc: expr.loc}, {...next_ctx, has_partial, partial_ident, partial_foo: prlt}

    else:
      [a, b, c] = transform_arg expr, args_id, {...p_ctx, partial_ident, has_partial}
      [a, b, {...c, has_partial: true}]



transform_all_args = fn [expr=false, ...exprs], args_id, ctx, out=[]:
  match expr:
    false:
      [out, args_id, ctx]

    {type: 'spread'}:
      [arg, next_args_id, next_ctx] = transform_spread_arg expr, args_id, ctx
      transform_all_args exprs, next_args_id, next_ctx, [...out, ...arg]

    {type: 'empty'}:
      # TODO: have a transform for empty
      [arg, next_args_id, next_ctx] = add_arg args_id, [], {i: '_', loc: expr.loc}, expr, ctx
      transform_all_args exprs, next_args_id, next_ctx, [...out, ...arg]

    {type: 'partial'}:
      [arg, next_args_id, next_ctx] = transform_partial_arg expr, args_id, ctx
      transform_all_args exprs, next_args_id, next_ctx, [...out, ...arg]

    else:
      [arg, next_args_id, foo_ctx] = transform_arg expr, args_id, ctx
      next_ctx = rec:
        ...foo_ctx
        partial_ident: ctx.partial_ident
        has_partial: ctx.has_partial or foo_ctx.has_partial
      transform_all_args exprs, next_args_id, next_ctx, [...out, ...arg]



transform_args = fn expr, ctx:
  args = match expr.args:
    # TODO should this be done in larix ?
    [{type: 'empty'}, ...(is_empty ?)]: []
    else: expr.args

  [empty_args, empty_args_id, args_ctx] = lst_name 'cargs', expr, ctx
  [out, args_id, next_ctx] = transform_all_args args, empty_args_id, args_ctx
  [[...empty_args, ...out], args_id, next_ctx]



transform_callee = fn expr, ctx:
  [foo, prtl, foo_ctx] = maybe_set_partial_ident 'prtlc', expr, ctx
  [callee, callee_id, {has_partial: hp, ...next_ctx}] = transform expr, 'callee', foo_ctx

  match true:
    foo and hp:
      [callee, callee_id, {...next_ctx, partial_foo: prtl, has_partial: true, partial_ident: ctx.partial_ident}]
    else:
      [callee, callee_id, {...next_ctx, has_partial: ctx.has_partial or hp, partial_ident: ctx.partial_ident}]



transform_call = fn node, result, ctx:
  [callee, c_id, args_ctx] = transform_callee node.callee, ctx
  [args, args_id, {partial_foo, ...end_ctx}] = transform_args node, args_ctx
  appl_fn = af c_id, args_id, node

  match partial_foo:
    ?:
      [res_id, foo_ctx] = unique_name 'pfn', node, end_ctx
      call = [...callee, ...args, [appl_fn, [res_id]]]
      func partial_foo, call, res_id, result, node, foo_ctx
    else:
      call = [...callee, ...args, [appl_fn, [result]]]
      [call, end_ctx]





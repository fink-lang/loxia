{add, any, unique_name} = import '../context.fnk'
{transform, ir_fn} = import '../transform.fnk'
{lst_empty, lst_a} = import '../literals/list.fnk'
{rec_empty, rec_s, rec_m} = import '../literals/record.fnk'
{str} = import '../literals/string.fnk'


jxe = fn name_id, props_id, chldrn_id, {loc}:
  ir_fn 'jxe', [name_id, props_id, chldrn_id], {loc}


jxf = fn children_id, {loc}:
  ir_fn 'jxf', [children_id], {loc}



transform_prop_name = fn expr, ctx:
  str expr.value, 'prpn', expr, ctx


transform_prop_val = fn expr, ctx:
  match expr:
    {name: {type: 'ident'}, value: false}:
      transform expr.name, 'prpv', ctx
    else:
      transform expr.value, 'prpv', ctx



transform_prop = fn expr, rec_id, ctx:
  [next_rec_id, key_ctx] = unique_name 'props', expr, ctx
  match expr:
    {type: 'spread'}:
      [val, val_id, next_ctx] = transform expr.right, 'sprd', key_ctx
      rc = rec_m rec_id, val_id, expr
      [[...val, [rc, [next_rec_id]]], next_rec_id , next_ctx]

    else:
      [key, key_id, val_ctx] = transform_prop_name expr.name, key_ctx
      [val, val_id, next_ctx] = transform_prop_val expr, val_ctx
      rc = rec_s rec_id, key_id, val_id, expr
      [[...key, ...val, [rc, [next_rec_id]]], next_rec_id, next_ctx]



transform_all_props = fn [expr=false, ...rest], rec_id, ctx, out=[]:
  match expr:
    false:
      [out, rec_id, ctx]
    else:
      [kv, next_rec_id, next_ctx] = transform_prop expr, rec_id, ctx
      transform_all_props rest, next_rec_id, next_ctx, [...out, ...kv]



transform_props = fn {props, loc}, ctx:
  [start_id, props_ctx] = unique_name 'props', {loc}, ctx
  [out, rec_id, next_ctx] = transform_all_props props, start_id, props_ctx
  rc = rec_empty {loc}
  [[[rc, [start_id]], ...out], rec_id, next_ctx]




transform_child = fn expr, lst_id, ctx:
  [next_lst_id, item_ctx] = unique_name 'chldrn', expr, ctx
  [item, item_id, next_ctx] = transform expr, 'chld', item_ctx
  lst = lst_a lst_id, item_id, expr
  [[...item, [lst, [next_lst_id]]], next_lst_id, next_ctx]



transform_all_children = fn [expr=false, ...rest], lst_id, ctx, out=[]:
  match expr:
    false:
      [out, lst_id, ctx]
    else:
      [child, out_lst_id, next_ctx] = transform_child expr, lst_id, ctx
      transform_all_children rest, out_lst_id, next_ctx, [...out, ...child]



transform_children = fn {children, loc}, ctx:
  [start_id, chldrn_ctx] = unique_name 'chldrn', {loc}, ctx
  [out, lst_id, next_ctx] = transform_all_children children, start_id, chldrn_ctx
  lst = lst_empty {loc}
  [[[lst, [start_id]], ...out], lst_id, next_ctx]



transform_jsx_elem = fn node, res_id, ctx:
  [name, name_id, props_ctx] = transform node.name, 'jsxi', ctx
  [props, props_id, chldrn_ctx] = transform_props node, props_ctx
  [chldrn, chldrn_id, next_ctx] = transform_children node, chldrn_ctx
  elem = jxe name_id, props_id, chldrn_id, node
  [[...name, ...props, ...chldrn, [elem, [res_id]]], next_ctx]



transform_jsx_frag = fn node, res_id, ctx:
  [chldrn, chldrn_id, next_ctx] = transform_children node, ctx
  elem = jxf chldrn_id, node
  [[...chldrn, [elem, [res_id]]], next_ctx]



transform_jsx_text = fn node, res_id, ctx:
  [txt, , next_ctx] = str node.value, res_id, node, ctx
  [txt, next_ctx]



transform_jsx_expr_container = fn node, res_id, ctx:
  [val, , next_ctx] = transform node.expr, res_id, ctx, false
  [val, next_ctx]



add_jsx = fn ctx:
  pipe ctx:
    add 'jsx:frag', any, transform_jsx_frag
    add 'jsx:elem', any, transform_jsx_elem
    add 'jsx:text', any, transform_jsx_text
    add 'jsx:expr', any, transform_jsx_expr_container


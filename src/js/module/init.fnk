types = import '@babel/types'
{
  file, program, exportNamedDeclaration, identifier
  assignmentExpression, expressionStatement
  memberExpression, callExpression, objectProperty, objectPattern
  variableDeclaration, variableDeclarator
  isImportDefaultSpecifier, isImportSpecifier, interpreterDirective
} = types

{map, fold} = import '@fink/std-lib/iter.fnk'
{slice} = import '@fink/std-lib/str.fnk'


{add, get_js, set_js, get_js_literal} = import '../context.fnk'
{transform_exprs} = import '../transform.fnk'
{escape_ident} = import '../identifier/init.fnk'


[no_result] = []


transform_specifiers = fn {specifiers, source}:
  init = callExpression
    identifier 'require'
    [source]

  [first] = specifiers

  match first:
    isImportDefaultSpecifier ?:
      [{local}] = specifiers
      variableDeclaration 'const', [variableDeclarator local, init]

    isImportSpecifier ?:
      props = pipe specifiers:
        map fn node:
          objectProperty
            node.imported
            node.local
            false
            node.imported.name == node.local.name
        [...?]

      variableDeclaration 'const', list:
        variableDeclarator
          objectPattern [...props]
          init

    else:
      expressionStatement init



module_transforms = rec:
  ImportDeclaration: fn path:
    path.replaceWith transform_specifiers path.node
    no_result

  ExportNamedDeclaration: fn path:
    {declaration: {declarations}} = path.node
    exports = identifier 'exports'

    pipe declarations:
      fold fn {id, init}:
        path.insertAfter
          expressionStatement
            assignmentExpression
              '='
              memberExpression exports, id
              init

    path.remove _
    no_result



transform_mod_exports = fn expr, ctx:
  [ , [exports_id], [res_id]] = expr

  decls = pipe get_js exports_id, ctx:
    ?.properties
    map fn {key, value}:
      name = match key:
        {type: 'StringLiteral'}: key.value
        else: key.name

      ident = rec:
        ...identifier escape_ident name
        loc: key.loc

      variableDeclarator ident, value
    [...?]

  js = exportNamedDeclaration variableDeclaration 'const', decls

  set_js res_id, js, ctx



transfrom_module = fn exprs, ctx:
  [body, next_ctx] = transform_exprs exprs, ctx
  [..., last] = exprs
  [ , [ , drctvs_id]] = last

  drctvs = get_js_literal drctvs_id, next_ctx

  directives = match drctvs:
    {elements: [{type: 'TemplateLiteral'}]}:
      [{quasis: [{value: {raw: value}}]}] = drctvs.elements
      [interpreterDirective slice value, 2]
    else:
      []

  js = file
    program
      body
      []
      'module'
      ...directives

  {...next_ctx, js}



add_module = fn ctx:
  pipe ctx:
    add 'mod', transform_mod_exports



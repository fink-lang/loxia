types = import '@babel/types'
{
  arrowFunctionExpression, blockStatement, returnStatement, restElement
  labeledStatement, doWhileStatement, booleanLiteral
} = types

{map} = import '@fink/std-lib/iter.fnk'

{get_refs, update_value} = import '../../ir/context.fnk'
{transform_exprs} = import '../transform.fnk'
{add, set_js, set_js2, with_loc} = import '../context.fnk'
{ident} = import '../identifier/init.fnk'



clean_args = fn args_id, args, body, ctx:
  fn_args = match [args, get_refs args_id, ctx]:
    # TODO use is_empty
    [{length: 0}, ? > 0]:
      [with_loc args_id, restElement ident args_id, ctx]
    else:
      [..., last] = args
      pipe args:
        map fn arg: match arg:
          last: arg
          {type: 'RestElement'}: arg.argument
          else: arg
        [...?]

  [fn_args, body, ctx]


split_args_body = fn [expr=false, ...exprs], args_id, ctx, args=[], body=[]:
  match expr:
    false:
      [args_id, args, body, ctx]

    [{f: 'lst_h', args: [{i: args_id.i}]}]:
      [...prev, ] = match args:
        [?, ?]: args
        else: [...args, ]

      [, [head_id]] = expr
      arg = ident head_id
      next_ctx = set_js2 expr, arg, ctx
      split_args_body exprs, args_id, next_ctx, [...prev, arg], body

    [{f: 'lst_r', args: [{i: args_id.i}]}]:
      split_args_body [], args_id, ctx, args, [...body, expr, ...exprs]

    [{f: 'lst_t', args: [{i: args_id.i}]}]:
      [, [tail_id]] = expr
      arg = ident tail_id
      rest = with_loc arg, restElement arg

      match get_refs tail_id, ctx:
        # the rest is used for more than just getting next arg and tail
        ? > 2:
          split_args_body [], tail_id, ctx, [...args, rest], [...body, ...exprs]
        # this is an ignored arg or last spread
        else:
          split_args_body exprs, tail_id, ctx, [...args, rest], body

    [{f: ? in ['fn', 'cn']}]:
      [foo, bar] = expr
      {args: [fargs, fbody]} = foo
      [next_args_id, next_args, next_body, next_ctx] = split_args_body fbody, args_id, ctx, args
      nexpr = [{...foo, args: [fargs, next_body]}, bar]
      split_args_body exprs, next_args_id, next_ctx, next_args, [...body, nexpr]

    else:
      split_args_body exprs, args_id, ctx, args, [...body, expr]



transform_normal_fn = fn expr, ctx:
  [{args: [fn_args, fn_block]}, [res_id]] = expr
  [args_id, ret_id, self_id=false] = fn_args

  ret = rec:
    ...returnStatement _
    leadingComments: [{type: 'CommentBlock', value: ' istanbul ignore next '}]

  self_ctx = set_js ret_id, ret, ctx

  body_ctx = match self_id:
    false: self_ctx
    else:
      pipe self_ctx:
        # set recursive calls to use res_id
        # instead of using a Z-combinator and self_id
        set_js self_id, (ident res_id), ?
        # make sure calls to self_id always use res_id
        update_value self_id, {ignore_refs: true}, ?

  [args, block, fn_ctx] = pipe body_ctx:
    split_args_body fn_block, args_id, ?
    clean_args ...?

  [body, next_ctx] = transform_exprs block, fn_ctx

  js = arrowFunctionExpression args, blockStatement body

  set_js2 expr, js, next_ctx



# TODO merge with transform_normal_fn
transform_tco_fn = fn expr, ctx:
  [{args: [fn_args, block]}, [res_id]] = expr
  [args_id, ret_id, self_id] = fn_args

  ret = rec:
    ...returnStatement _
    leadingComments: [{type: 'CommentBlock', value: ' istanbul ignore next '}]

  body_ctx = pipe ctx:
    # set recursive calls and continue label to use res_id
    # instead of a Z-combinator and self_id
    set_js ret_id, ret, ?
    set_js self_id, (ident res_id), ?
    # make sure continue statements and calls to self_id always use res_id
    update_value self_id, {args_id, label_id: res_id, ignore_refs: true}, ?

  [body, next_ctx] = transform_exprs block, body_ctx

  js = arrowFunctionExpression
    [restElement ident args_id]
    blockStatement list:
      labeledStatement
        ident res_id
        doWhileStatement
          booleanLiteral true
          blockStatement body

  set_js2 expr, js, next_ctx



transform_fn = fn expr, ctx:
  match expr:
    [{tco: true}]:
      transform_tco_fn expr, ctx
    else:
      transform_normal_fn expr, ctx



transform_cont = fn expr, ctx:
  [{args: [args, block]}] = expr

  [ret_id=false] = args
  [body, next_ctx]= transform_exprs block, ctx

  js = match ret_id:
    false:
      blockStatement body
    else:
      labeledStatement
        ident ret_id
        blockStatement body

  set_js2 expr, js, next_ctx



add_funcs = fn ctx:
  pipe ctx:
    add 'fn', transform_fn
    add 'cn', transform_cont


babel_types = import '@babel/types'
{
  assignmentExpression, returnStatement
  isDoExpression, isBlockStatement, isLabeledStatement
  isVariableDeclarator, isArrowFunctionExpression, isExpressionStatement
  isAssignmentExpression
  isReturnStatement
  arrowFunctionExpression, callExpression, blockStatement
} = babel_types
{set_props} = import '@fink/js-interop/reflect.fnk'
{undefined} = import '@fink/js-interop/nullish.fnk'
{fold, map, is_empty} = import '@fink/std-lib/iter.fnk'
{wrap_with_comment_loc} = import './comments/init.fnk'

{lets, assign, undef} = import './types.fnk'


get_body = ?.get 'body'



consume_all = fold fn: undefined



simple = fn body, sl=false:
  match body:
    isBlockStatement ?:
      [stmnt, ...rest] = get_body body

      match rest:
        is_empty ?:
          # e.g. fn arg: match ...: ...
          match {sl, stmnt}:
            {sl: true, stmnt: isLabeledStatement ?}:
              stmnt.node.body
            else:
              simple stmnt
        else:
          body.node
    else:
      body.node



last_expressions = fn path:
  match path:
    isDoExpression ?:
      body = get_body path
      [...last_expressions body]

    isBlockStatement ?:
      body = get_body path
      [..., last] = body
      match last:
        isExpressionStatement ?:
          [last]
        else:
          [...last_expressions last]

    --- istanbul ignore else ---
    isLabeledStatement ?:
      body = get_body path

      # TODO: don't use mutable obj
      items = []
      body.traverse
        rec:
          LabeledStatement: ?.skip _

          BreakStatement: fn brk:
            last = brk.getSibling brk.key - 1
            items.push last
            undefined
      items



replace_with_return = fn path:
  pipe last_expressions path:
    map fn expr:
      expr.replaceWith
        wrap_with_comment_loc
          returnStatement expr.node.expression
          expr.node.expression

      # TODO: no need for e.g. breaks after a return
      sibl = expr.getSibling expr.key + 1
      match sibl:
        # TODO `?:`
        --- istanbul ignore next ---
        {}:
          sibl.remove _

    consume_all



replace_with_assign = fn target, path:
  id = path.parentPath.scope.generateUidIdentifier 'do_result'
  #TODO: don't mutate
  set_props target.node, {init: id}

  # TODO: needs loc
  target.parentPath.insertBefore lets id
  target.parentPath.insertBefore simple get_body path
  target.parentPath.insertAfter assign id, undef _

  pipe last_expressions path:
    map fn expr:
      expr.replaceWith
        wrap_with_comment_loc
          assignmentExpression '=', id, expr.node.expression
          expr.node.expression

    consume_all


replace_with_simple_assign = fn target, path:
  id = target.node.left
  target.parentPath.insertBefore blockStatement path.node.body.body

  pipe last_expressions path:
    map fn expr:
      expr.replaceWith
        wrap_with_comment_loc
          assignmentExpression '=', id, expr.node.expression
          expr.node.expression

    consume_all

  target.replaceWithMultiple []



transform_do_expr = fn path:
  {parentPath: parent} = path

  match parent:
    isVariableDeclarator ?:
      replace_with_assign parent, path

    isArrowFunctionExpression ?:
      body = get_body path

      set_props parent.node, {body: simple body, true}

      replace_with_return path

    isExpressionStatement ?:
      # this is used e.g. for conditional at the module level
      parent.replaceWith
        get_body path

    isReturnStatement ?:
      body = get_body path

      parent.replaceWith
        simple body, true

      replace_with_return path


    isAssignmentExpression ?:
      replace_with_simple_assign parent, path

    else:
      # TODO: {spam.ham.ni: {foo, bar} = spam
      arrow = arrowFunctionExpression [], path.node
      path.replaceWith
        callExpression arrow, []

  undefined

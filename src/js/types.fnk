babe_types = import '@babel/types'
{is_empty} = import '@fink/std-lib/iter.fnk'


{escape_ident} = import'./identifier.fnk'

{
  variableDeclaration, variableDeclarator
  forOfStatement, yieldExpression, nullLiteral, booleanLiteral
  expressionStatement, functionExpression
  blockStatement, identifier, arrowFunctionExpression
  logicalExpression, binaryExpression, unaryExpression
  doExpression, assignmentExpression, isIdentifier, objectExpression,
  returnStatement, objectMethod, memberExpression
} = babe_types



wrap = fn larix_node, js_node:
  {...js_node, loc: larix_node.loc}


expr_block = fn ...exprs:
  doExpression
    blockStatement list:
      ...pipe exprs:
        map node:
          match node:
            # TODO: was used, why not anymore?
            # {type: ends_with ?, 'Expression'}:
            #   expressionStatement node
            isIdentifier ?:
              expressionStatement node
            else: node


typof = fn value: unaryExpression 'typeof', value


and = fn left, ...rest:
  match rest:
    is_empty ?:
      left
    else:
      logicalExpression '&&', left, and ...rest


neq = fn left, right: binaryExpression '!==', left, right

eq = fn left, right: binaryExpression '===', left, right

undef = fn: identifier 'undefined'


true_ = fn: booleanLiteral true
false_ = fn: booleanLiteral false


not_nullish = fn value:
  not_null = neq value, nullLiteral _
  not_undef = neq value, undef _
  and not_undef, not_null


ident = fn name, ctx:
  identifier escape_ident name, ctx



unique_ident = fn name, ctx:
  {unique_id, ident_prefix} = ctx
  js = ident '${ident_prefix}${name}_${unique_id}', ctx
  [js, {...ctx, unique_id: unique_id + 1}]



raw_str = fn value:
  dict:
    type: 'StringLiteral'
    value
    extra: dict:
      raw: '"${value}"'
      rawValue: value


consts = fn left, init:
  variableDeclaration
    'const'
    [variableDeclarator left, init]


lets = fn left, init:
  variableDeclaration
    'let'
    [variableDeclarator left, init]


assign = fn left, right:
  expressionStatement
    assignmentExpression '=', left, right


yields = fn expr, delegate:
  expressionStatement
    yieldExpression expr, delegate


func = fn args, ...expressions:
  arrowFunctionExpression
    args
    expr_block ...expressions


symbol = fn symb:
  memberExpression
    identifier 'Symbol'
    identifier symb


computed = true
async = true


generator = fn name, args, ...statements:
  functionExpression name, args,
    blockStatement list:
      returnStatement
        objectExpression list:
          objectMethod
            'method', (symbol 'iterator'), []
            blockStatement list:
              ...statements
            computed
            async


for_of = fn [item, items], ...expressions:
  forOfStatement
    consts item
    items
    blockStatement expressions

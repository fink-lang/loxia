{
  variableDeclaration, variableDeclarator, arrayPattern,
  objectPattern, assignmentPattern, forOfStatement, yieldExpression,
  expressionStatement, callExpression, functionExpression,
  blockStatement, identifier, arrowFunctionExpression,
  logicalExpression, binaryExpression, unaryExpression,
  stringLiteral, memberExpression, ifStatement, doExpression,
  assignmentExpression, returnStatement,
  isAssignmentExpression, isObjectExpression,
  isArrayExpression, isIdentifier
} = import'@babel/types'

{get_comment} = import'../lang/comments'

{escape_ident} = import'./identifier'


wrap = fn larix_node, js_node:
  {...js_node, ...get_comment(larix_node), loc: larix_node.loc}


expr_block = fn ...exprs:
  doExpression(
    blockStatement([
      ...pipe exprs:
        map node:
          match true:
            (node.type.endsWith('Expression') || isIdentifier(node)):
              expressionStatement(node)
            else:
              node
    ])
  )


member = fn obj: fn key, computed:
  memberExpression(obj, key, computed)


str = fn txt: stringLiteral(txt)


typof = fn value: unaryExpression('typeof', value)


split_last = fn [...items]:
  [items.slice(0, -1), items.(items.length - 1)]


and = fn left, ...rest:
  match true:
    rest.length > 0:
      logicalExpression('&&', left, and(...rest))
    else:
      left


neq = fn left, right: binaryExpression('!==', left, right)

eq = fn left, right: binaryExpression('===', left, right)

undef = fn: identifier('undefined')

nul = fn: identifier('null')

true_ = fn: identifier('true')


not_nullish = fn value:
  and(
    neq(value, undef()),
    neq(value, nul())
  )


ident = fn name:
  match name:
    # TODO: typeof name == 'string': identifier(escape_ident(name)) or
    {constructor: String}: identifier(escape_ident(name))
    else:
      # {type: 'Identifier'}
      # {type: 'ObjectPattern'}
      # {type: 'ArrayPattern'}
      # {type: 'AssignmentPattern'}
      name


consts = fn id, init:
  variableDeclaration('const', [variableDeclarator(ident(id), init)])


lets = fn id, init:
  variableDeclaration('let', [variableDeclarator(ident(id), init)])


call = fn callee: fn ...args:
  callExpression(callee, args)


assign = fn left, right:
  expressionStatement(assignmentExpression('=', left, right))


yields = fn expr, delegate:
  expressionStatement(yieldExpression(expr, delegate))


iff = fn test: fn consequent:
  ifStatement(test, consequent)


returns = fn expr: returnStatement(expr)


yield_or_stop = fn expr, unique_ident, delegate:
  result = unique_ident('result')

  [
    consts(result, expr),
    yields(result, delegate)
  ]


func = fn ...args: fn expr, ...expressions:
  arrowFunctionExpression(
    args,
    expr_block(expr, ...expressions)
  )


generator = fn name: fn ...args: fn ...statements:
  functionExpression(
    ident(name),
    args,
    blockStatement(statements),
    true
  )


for_of = fn item, items: fn ...expressions:
  forOfStatement(
    consts(item), items,
    blockStatement(expressions)
  )


params = fn exprs:
  [...args] = pipe exprs:
    map expr:
      match true:
        isAssignmentExpression(expr):
          assignmentPattern(expr.left, expr.right)

        isObjectExpression(expr):
          objectPattern(params(expr.properties))

        isArrayExpression(expr):
          arrayPattern(params(expr.elements))

        # TODO: was previously used.
        #  (isSpreadElement(expr):
        #     restElement(expr.argument)
        #
        else: expr
  args


types = import '@babel/types'
{
  binaryExpression, unaryExpression, expressionStatement
  variableDeclaration, variableDeclarator
} = types

# {throw_err} = import '@fink/js-interop/errors.fnk'
# {transform_error} = import '../ir/errors.fnk'

{get_transformer, get_js, get_js_literal, set_js2, with_loc} = import './context.fnk'
{get_refs} = import '../ir/context.fnk'
{ident} = import './identifier/init.fnk'



ops_to_js = rec:
  '^': '**'
  '==': '==='
  '!=': '!=='
  'not': '!'



transform_binary = fn expr, ctx:
  [{f: op, args: [left_id, right_id]}] = expr
  left = get_js left_id, ctx
  right = get_js right_id, ctx
  {(op): jsop=op} = ops_to_js
  js = binaryExpression jsop, left, right
  set_js2 expr, js, ctx



transform_unary = fn expr, ctx:
  [{f: op, args: [right_id]}] = expr
  right = get_js right_id, ctx
  {(op): jsop=op} = ops_to_js
  js = unaryExpression jsop, right
  set_js2 expr, js, ctx



transform_binary_or_unary = fn expr, ctx:
  match expr:
    [{args: [, ?]}]: transform_binary expr, ctx
    else: transform_unary expr, ctx



transform = fn expr, ctx:
  transform_expr = get_transformer expr, ctx
  # match transform_expr:
  #   ?:
  #     transform_expr expr, ctx
  #   else:
  #     [, , , fnk_expr] = expr
  #     throw_err transform_error 'Unknown expression.', fnk_expr, ctx
  transform_expr expr, ctx



transform_exprs = fn [expr=false, ...exprs], ctx, body=[]:
  match expr:
    false: [body, ctx]

    [{f: ? in ['cf', 'cc', 'cif', 'ac', 'imp']}]:
      [body_exprs, next_ctx] = transform expr, ctx
      transform_exprs exprs, next_ctx, [...body, ...body_exprs]

    [{f: 'cn'}]:
      next_ctx = transform expr, ctx
      transform_exprs exprs, next_ctx, body

    [{f: 'mod'}]:
      [, [res_id]] = expr
      next_ctx = transform expr, ctx
      js = get_js_literal res_id, next_ctx
      transform_exprs exprs, next_ctx, [...body, js]

    [ , [?]]:
      [{f: op}, [res_id]] = expr
      next_ctx = transform expr, ctx

      match [op, get_refs res_id, next_ctx]:
        [, ? > 1]:
          val = get_js_literal res_id, next_ctx
          js = match val:
            {type: 'VariableDeclaration'}:
              # TODO: use loc from res_id, val or expr?
              with_loc {res_id}, val
            else:
              # TODO: use loc from res_id, val or expr?
              # id = with_loc {loc: todo}, ident res_id
              id = ident res_id
              with_loc res_id, variableDeclaration 'const', list:
                with_loc res_id, variableDeclarator id, val

          transform_exprs exprs, next_ctx, [...body, js]

        # unused calls assumed to have side effects
        ['af', ? == 0]:
          val = get_js_literal res_id, next_ctx
          js = with_loc res_id, expressionStatement val
          transform_exprs exprs, next_ctx, [...body, js]

        else:
          transform_exprs exprs, next_ctx, body






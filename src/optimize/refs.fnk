{reverse} = import '@fink/std-lib/iter.fnk'

{update_value, get_value, unique_name} = import '../ir/context.fnk'



replace_arg_alias = fn arg, ctx:
  {alias: new_arg=arg} = get_value arg, ctx
  match new_arg:
    arg: arg
    else: replace_arg_alias new_arg, ctx



replace_args_aliases = fn [arg=false, ...args], ctx, out=[]:
  match arg:
    false:
      out
    else:
      renamed_arg = replace_arg_alias arg, ctx
      # TODO: carry loc over?
      replace_args_aliases args, ctx, [...out, {...renamed_arg, loc: arg.loc}]



optimize_args = fn expr, ctx:
  {args} = expr
  o_args = replace_args_aliases args, ctx
  {...expr, args: o_args}



add_alias = fn id, target, ctx:
  # TODO: loc?
  # update_value id, {alias: {...id, i: target.i}}, ctx
  update_value id, {alias: target}, ctx



optimize_lst = fn [expr, res], ctx:
  [res_id] = res
  opt_expr = optimize_args expr, ctx
  next_ctx = update_value res_id, {empty_tpl: true, item_aliases: []}, ctx
  [[opt_expr, res], next_ctx]



add_lst_aliases = fn {args: [lst_id, val_id]}, res_id, ctx:
  {item_aliases=[]} = get_value lst_id, ctx
  update_value res_id, {item_aliases: [...item_aliases, val_id]}, ctx



optimize_lst_a = fn [expr, res], ctx:
  [res_id] = res
  opt_expr = optimize_args expr, ctx
  next_ctx = add_lst_aliases opt_expr, res_id, ctx
  [[[opt_expr, res]], next_ctx]



optimize_lst_h = fn [expr, res], ctx:
  [res_id] = res
  opt_expr = optimize_args expr, ctx
  {args: [lst_id]} = opt_expr
  info = get_value lst_id, ctx
  match info:
    {item_aliases: [?]}:
      {item_aliases: [val_id]} = info
      next_ctx = add_alias res_id, val_id, ctx
      [[], next_ctx]
    else:
      [[[opt_expr, res]], ctx]



optimize_lst_t = fn [expr, res], ctx:
  [res_id] = res
  opt_expr = optimize_args expr, ctx
  {args: [lst_id]} = opt_expr
  info = get_value lst_id, ctx
  match info:
    {item_aliases: [?]}:
      {item_aliases: [, ...item_aliases]} = info
      next_ctx = update_value res_id, {item_aliases}, ctx
      [[[opt_expr, res]], next_ctx]
    else:
      [[[opt_expr, res]], ctx]



is_empty_lst = fn id, ctx:
  match get_value id, ctx:
    {empty_tpl: true}: true
    else: false



optimize_lst_c = fn [expr, res], ctx:
  [res_id] = res
  opt_expr = optimize_args expr, ctx
  {args: [lst1_id, lst2_id]} = opt_expr

  match ctx:
    is_empty_lst lst2_id, ?:
      next_ctx = add_alias res_id, lst1_id, ctx
      [[], next_ctx]
    else:
      [[[opt_expr, res]], ctx]



create_lst = fn [id=false, ...ids], lst_id, tmp_id, ctx, out=[]:
  match id:
    false:
      [[[{f: 'lst', args: [], loc: lst_id.loc}, [tmp_id]], ...out], ctx]

    else:
      [next_tmp_id, end_ctx] = unique_name lst_id.i, lst_id, ctx
      lst = [{f: 'lst_a', args: [next_tmp_id, id], loc: id.loc}, [tmp_id]]
      create_lst ids, lst_id, next_tmp_id, end_ctx, [lst, ...out]



optimize_lst_r = fn [expr, res], ctx:
  [res_id] = res
  opt_expr = optimize_args expr, ctx
  {args: [lst_id]} = opt_expr
  info = get_value lst_id, ctx

  match info:
    {tpr: ?}:
      {tpr} = info
      next_ctx = add_alias res_id, tpr, ctx
      [[], next_ctx]

    {item_aliases: ?}:
      {item_aliases: rev_aliases} = info
      # find existing tpl instead of creating
      item_aliases = reverse rev_aliases
      lst_ctx = update_value res_id, {item_aliases, tpr: lst_id}, ctx
      create_lst rev_aliases, res_id, res_id, lst_ctx

    else:
      next_ctx = update_value res_id, {tpr: lst_id}, ctx
      [[[opt_expr, res]], next_ctx]



optimize_body = fn [expr, res], ctx, optimize_refs:
  {args: [args, body]} = expr
  [o_body, next_ctx] = optimize_refs body, ctx, []
  [[[{...expr, args: [args, o_body]}, res]], next_ctx]



optimize_cn = fn [expr, res], exprs, ctx, optimize_refs, out:
  [cont_id] = res
  [[ret_id], body] = expr.args

  [
    [{f: ac_op, args: [ac_id]}, [res_id]]
    [{f: cc_op, args: [cc_ret_id, ret_arg]}]=[{args: []}]
  ] = exprs

  match [ac_op, ac_id, cc_op, res_id]:
    ['ac', cont_id, 'cc', ret_arg]:
      b_ctx = add_alias ret_id, cc_ret_id, ctx
      [o_body, next_ctx] = optimize_refs body, b_ctx, []
      [, , ...oexprs] = exprs
      optimize_refs oexprs, next_ctx, [...out, ...o_body]

    else:
      [of_cn, next_ctx] = optimize_body [expr, res], ctx, optimize_refs
      optimize_refs exprs, next_ctx, [...out, ...of_cn]



optimize_refs = fn [expr=false, ...exprs], ctx, out=[]:

  match expr:
    false:
      [out, ctx]

    [{f:'lst'}]:
      [opt, next_ctx] = optimize_lst expr, ctx
      optimize_refs exprs, next_ctx, [...out, opt]

    [{f: 'lst_a'}]:
      [opt, next_ctx] = optimize_lst_a expr, ctx
      optimize_refs exprs, next_ctx, [...out, ...opt]

    [{f:'lst_h'}]:
      [opt, next_ctx] = optimize_lst_h expr, ctx
      optimize_refs exprs, next_ctx, [...out, ...opt]

    [{f: 'lst_t'}]:
      [opt, next_ctx] = optimize_lst_t expr, ctx
      optimize_refs exprs, next_ctx, [...out, ...opt]

    [{f: 'lst_c'}]:
      [opt, next_ctx] = optimize_lst_c expr, ctx
      optimize_refs exprs, next_ctx, [...out, ...opt]

    [{f: 'lst_r'}]:
      [opt, next_ctx] = optimize_lst_r expr, ctx
      optimize_refs exprs, next_ctx, [...out, ...opt]

    [{f: '='}]:
      [{args: [target]}, [res_id]] = expr
      next_ctx = add_alias res_id, target, ctx
      optimize_refs exprs, next_ctx, out

    [{f: ? in ['int', 'float', 'str']}]:
      optimize_refs exprs, ctx, [...out, expr]

    [{f: 'cn'}]:
      orf = optimize_refs
      optimize_cn expr, exprs, ctx, orf, out

    [{f: 'fn'}]:
      orf = optimize_refs
      [opt, next_ctx] = optimize_body expr, ctx, orf
      optimize_refs exprs, next_ctx , [...out, ...opt]

    [{f: '+'}]:
      [foo, res] = expr
      o_expr = optimize_args foo, ctx
      optimize_refs exprs, ctx, [...out, [o_expr, res]]

    else:
      [foo, res] = expr
      o_expr = optimize_args foo, ctx
      optimize_refs exprs, ctx, [...out, [o_expr, res]]


babel_types = import '@babel/types'
{callExpression, doExpression, blockStatement} = babel_types
{is_empty} = import '@fink/std-lib/iter.fnk'

{assign, lets, undef, unique_ident} = import '../../js/types.fnk'
{wrap_with_comment_loc} = import '../comments/init.fnk'
{transform, map_with_ctx, collect_with_ctx} = import '../transform.fnk'
{transform_with_partial} = import '../partial/init.fnk'



transform_pipe_step = fn result: fn expr, ctx:
  callee_ctx = {...ctx, partial_ident: result}

  [is_partial, callee, {partial_ident: _, ...next_ctx}] = transform_with_partial expr, callee_ctx, false

  step = match is_partial:
    false:
      assign result, callExpression callee, [result]
    else:
      assign result, callee

  js = wrap_with_comment_loc step, expr
  [js, next_ctx]



transform_pipe = fn node, ctx:
  {exprs} = node

  [start_value, id_ctx] = match node.args:
    is_empty ?:
      [(undef _), ctx]
    else:
      [arg] = node.args
      transform arg, ctx

  [result, pipe_ctx] = unique_ident 'pipe_result', id_ctx

  [pipe_calls, next_ctx] = pipe exprs:
    map_with_ctx transform_pipe_step result
    collect_with_ctx pipe_ctx

  js = doExpression
    blockStatement list:
      wrap_with_comment_loc
        lets result, start_value
        start_value
      ...pipe_calls

  [js, next_ctx]
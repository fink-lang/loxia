babel_types = import '@babel/types'
{callExpression, identifier} = babel_types

{map, filter, zip, length} = import '@fink/std-lib/iter.fnk'

{transform, map_with_ctx, collect_with_ctx} = import '../transform.fnk'
{transform_with_partial, partial_wrapper, no_wrapper} = import '../partial/init.fnk'



transform_multiple_args = fn args, ctx:
  pipe args:
    map_with_ctx fn expr, arg_ctx:
      match expr:
        {type: 'empty'}:
          [(identifier 'undefined'), arg_ctx]
        else:
          transform expr, arg_ctx
    collect_with_ctx ctx



transform_single_arg = fn [expr], ctx:
  match expr:
    {type: 'empty'}:
      [[],  ctx]
    else:
      transform_multiple_args [expr], ctx



transform_args = fn args, ctx, default_wrap_partial:
  [js_args, next_ctx] = match args:
    1 == length ?:
      transform_single_arg args, ctx
    else:
      transform_multiple_args args, ctx

  [wrap_partial=default_wrap_partial] = pipe zip args, js_args:
    filter fn [arg, js_arg]: match arg:
      {type: 'partial'}: true
      {type: 'spread', right: {type: 'partial'}}: true
      {type: 'spread'}: js_arg.is_partial
      else: false
    map fn: partial_wrapper

  [wrap_partial, js_args, next_ctx]




transform_call = fn node, ctx:
  [callee, wrap_partial, args, end_ctx] = match node.callee:
    # TODO: small pipe foo | bar ?, spam
    {type: 'call'}:
      [callee, args_ctx] = transform node.callee, ctx
      [callee, ...transform_args node.args, args_ctx, no_wrapper]
    else:
      [wrap_partial_callee, callee, args_ctx] = transform_with_partial node.callee, ctx
      [callee, ...transform_args node.args, args_ctx, wrap_partial_callee]

  js = callExpression callee, args

  wrap_partial js, end_ctx


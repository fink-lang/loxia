babel_types = import '@babel/types'
{identifier, arrowFunctionExpression} = babel_types

{add} = import '../context.fnk'
{transform} = import '../transform.fnk'





partial_wrapper = fn js, ctx:
  {partial_ident} = ctx
  name = match partial_ident:
    {name: {}}:
      partial_ident.name
    else:
      '${ctx.ident_prefix}partial'

  partial_id = identifier name
  [{is_partial: true, ...arrowFunctionExpression [partial_id], js}, ctx]


no_wrapper = fn js, ctx: [js, ctx]



transform_with_partial = fn expr, ctx, default_wrapper=no_wrapper:
  [js, next_ctx] = match expr:
    {type: 'partial'}:
      [js, next_ctx] = transform expr, ctx
      [{params: [js], body: js, is_partial: true}, next_ctx]
    else:
      transform expr, ctx

  match js:
    {is_partial: true}:
      [partial_wrapper, js.body, next_ctx]
    else:
      [default_wrapper, js, next_ctx]




transform_with_partial_lr = fn left, right, ctx:
  [wrapper_l, js_l, right_ctx] = transform_with_partial left, ctx
  [wrapper, js_r, next_ctx] = transform_with_partial right, right_ctx, wrapper_l

  [js_l, js_r, next_ctx, wrapper]




transform_partial = fn , ctx:
  {partial_ident} = ctx

  name = match partial_ident:
    {name: {}}:
      partial_ident.name
    else:
      '${ctx.ident_prefix}partial'

  js = identifier name

  [js, ctx]



add_partial = fn ctx:
  pipe ctx:
    add 'partial', '?', transform_partial

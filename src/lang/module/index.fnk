{
  file, program, objectProperty, identifier
  callExpression, objectExpression, memberExpression
  expressionStatement, interpreterDirective
} = import '@babel/types'

{call, member, ident} = import '../../js/types'
{add, any} = import '../context'

{block_statement} = import '../block'
{transform_import} = import './import'


# TODO should larix handle shebang as special expr?
get_shebang = fn expr:
  {comments} = expr
  match comments:
    {leading: [{op: '#', loc: {start: {line: 1}}, value: ?.startsWith '!'}]}:
      [first, ...rest] = comments.leading
      shebang = interpreterDirective '${first.value.slice 1}'
      [[shebang], {...expr, comments: {...comments, leading: rest}}]
    else:
      [[], expr]


transform_module = fn node, ctx:
  [...exported] = pipe node.exprs:
    filter expr:
      match expr:
        {left: {type: 'ident'}}: true
        else: false

    map {left: {value}}:
      # TODO: wrap with loc?
      id = ident value
      objectProperty id, id, false, true

  [maybe_shebang, ...rest] = node.exprs

  [interpreter, first] = get_shebang maybe_shebang

  [...body] = pipe [first, ...rest]:
    map expr: block_statement expr, ctx

  # TODO: use individual exports?
  obj = identifier 'Object'
  obj_assign = memberExpression obj, identifier 'assign'
  mod = identifier 'module'
  mod_exports = memberExpression mod, identifier 'exports'

  exports = expressionStatement
    callExpression
      obj_assign
      [mod_exports, objectExpression exported]

  file
    program
      [...body, exports]
      []
      'module'
      ...interpreter


add_module = fn ctx:
  pipe ctx:
    add 'module', any, transform_module
    add 'import', any, transform_import


babel_types = import '@babel/types'
{
  file, program, interpreterDirective, stringLiteral
  importDeclaration, importSpecifier, importDefaultSpecifier
  exportNamedDeclaration, exportDefaultDeclaration, identifier
} = babel_types
{starts_with, slice} = import '@fink/std-lib/str.fnk'

{add, any} = import '../context.fnk'
{wrap_with_comment_loc} = import '../comments/init.fnk'
{block_statement} = import '../block/init.fnk'
{transform, map_with_ctx} = import '../transform.fnk'

{transform_import: transform_async_import, resolve_ext} = import './import.fnk'



# TODO should larix handle shebang as special expr?
get_hashbang = fn expr:
  {comments} = expr
  match comments:
    {leading: [{op: '#', loc: {start: {line: 1}}, value: starts_with ?, '!'}]}:
      [first, ...rest] = comments.leading
      shebang = interpreterDirective '${slice first.value, 1}'
      [[shebang], {...expr, comments: {...comments, leading: rest}}]
    else:
      [[], expr]



transform_import = fn node, ctx:
  {options} = ctx

  [imports, end_ctx] = match node.left:
    {type: 'ident'}:
      [imp, next_ctx] = transform node.left, ctx
      [[importDefaultSpecifier imp], next_ctx]

    {type: 'rec'}:
      pipe node.left.exprs:
        map_with_ctx ctx, fn prop, imp_ctx:
          [right, left_ctx] = transform prop.right, imp_ctx

          match prop:
            {left: {value: 'default'}}:
              imp = importSpecifier right, identifier prop.left.value
              [imp, left_ctx]

            else:
              [left, next_ctx] = transform prop.left, left_ctx
              imp = importSpecifier right, left
              [imp, next_ctx]

  {right: {right: {exprs: [url]}}} = node

  js = importDeclaration
    imports
    wrap_with_comment_loc
      stringLiteral resolve_ext url.value, options
      node.right.right

  [js, end_ctx]



transform_module = fn node, ctx:
  [maybe_shebang, ...rest] = node.exprs
  [interpreter, first] = get_hashbang maybe_shebang

  [body, end_ctx] = pipe [first, ...rest]:
    map_with_ctx ctx, fn expr, expr_ctx:
      match expr:
        {op: 'import'}:
          {right: {exprs: [url]}} = expr
          js = wrap_with_comment_loc
            importDeclaration
              [], stringLiteral resolve_ext url.value, expr_ctx.options
            expr
          [js, expr_ctx]

        {right: {op: 'import'}}:
          [imp, next_ctx] = transform_import expr, expr_ctx
          js = wrap_with_comment_loc imp, expr
          [js, next_ctx]

        {type: 'assign', left: {type: 'ident', value: 'default'}}:
          [decl, next_ctx] = transform expr.right, expr_ctx
          js = wrap_with_comment_loc
            exportDefaultDeclaration decl
            expr
          [js, next_ctx]

        {type: 'assign', left: {type: 'ident'}}:
          # we don't want to double up on comments?
          {comments: _, ...decl} = expr
          [decl_st, next_ctx] = block_statement decl, expr_ctx
          js = wrap_with_comment_loc
            exportNamedDeclaration decl_st
            expr
          [js, next_ctx]

        else:
          block_statement expr, expr_ctx

  js = file
    program
      body
      []
      'module'
      ...interpreter

  [js, end_ctx]



add_module = fn ctx:
  pipe ctx:
    add 'module', any, transform_module
    add 'import', any, transform_async_import


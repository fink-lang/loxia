babel_types = import '@babel/types'
{objectExpression, objectProperty, assignmentPattern} = babel_types

{raw_str} = import '../../js/types.fnk'
{transform, collect_with_ctx} = import '../transform.fnk'


transform_record = fn node, ctx:
  [props, next_ctx] = pipe node.exprs:
    map key_value, prop_ctx=ctx:
      [prop, next_ctx] = transform key_value, prop_ctx
      ([prop, next_ctx], next_ctx)

    collect_with_ctx ctx

  js = objectExpression props

  [js, next_ctx]


str_key = fn {value, loc}, ctx:
  str = raw_str value
  [{...str, loc}, ctx]



get_key = fn {left: key}, ctx:
  match key:
    {type: 'group'}:
      [true, ...transform key, ctx]
    {type: 'string'}:
      [true, ...transform key, ctx]
    else:
      [false, ...str_key key, ctx]



get_value = fn {right}, ctx:
  match right:
    {type: 'empty'}:
      ident = ctx.unique_ident 'unused'
      [ident, ctx]
    else:
      transform right, ctx



transform_kv = fn node, ctx:
  match node:
    {left: {type: 'spread'}}:
      transform node.left, ctx
    else:
      [computed, key, next_ctx] = get_key node, ctx
      [value, end_ctx] = get_value node, next_ctx

      shorthand = node.left == node.right

      final_value = match node:
        {right: {type: 'assign'}}:
          assignmentPattern value.left, value.right
        else:
          value

      js = objectProperty key, final_value, computed, shorthand
      [js, end_ctx]



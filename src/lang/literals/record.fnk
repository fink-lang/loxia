babel_types = import '@babel/types'
{objectExpression, objectProperty, assignmentPattern} = babel_types

{raw_str, unique_ident, ident} = import '../../js/types.fnk'
{transform, map_with_ctx, collect_with_ctx} = import '../transform.fnk'


transform_record = fn node, ctx:
  [props, next_ctx] = pipe node.exprs:
    map_with_ctx transform
    collect_with_ctx ctx

  js = objectExpression props
  [js, next_ctx]



str_key = fn {value, loc}, ctx:
  str = raw_str value
  [{...str, loc}, ctx]



get_key = fn {left: key}, ctx:
  match key:
    {type: 'group'}:
      [true, ...transform key, ctx]
    {type: 'string'}:
      [true, ...transform key, ctx]
    else:
      id = ident key.value, ctx
      match id:
        {name: key.value}:
          [false, id, ctx]
        else:
          [false, ...str_key key, ctx]



get_value = fn {left, right}, ctx:
  match right:
    false:
      transform left, ctx
    {type: 'empty'}:
      unique_ident 'unused', ctx
    else:
      transform right, ctx



transform_kv = fn node, ctx:
  match node:
    ---istanbul ignore next---
    {type: 'spread'}:
      transform node, ctx

    {left: {type: 'spread'}}:
      transform node.left, ctx

    else:
      [computed, key, next_ctx] = get_key node, ctx
      [value, end_ctx] = get_value node, next_ctx

      shorthand = match node:
        {right: false}: true
        else: false

      final_value = match node:
        {right: {type: 'assign'}}:
          assignmentPattern value.left, value.right
        else:
          value

      js = objectProperty key, final_value, computed, shorthand
      [js, end_ctx]



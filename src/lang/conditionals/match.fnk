{
  arrayPattern, blockStatement, breakStatement, labeledStatement, objectPattern,
  objectProperty, isObjectExpression, isArrayExpression, expressionStatement,
  identifier
} = import '@babel/types'

{
  member, str, for_of, split_last, and, eq, not_nullish, typof,
  expr_block, consts, iff
} = import '../../js/types'

{is_call, is_calling} = import '../call/call'
{get_key} = import '../literals/object'
{is_array} = import '../literals/array'


iter = fn value:
  member(value)(member(identifier('Symbol'))(identifier('iterator')), true)


is_iterable = fn value:
  and(
    not_nullish(value),
    eq(
      typof(iter(value)), str('function')
    )
  )


is_partial = fn node:
  match node:
    {callee: {value: '?'}}: true
    {callee: {left: {value: '?'}}}: true
    {type: 'call'}:
      arg = pipe node.args:
        find arg:
          match arg:
            {value: '?'}: true
            else: false
      !!arg

    {type: 'comp', left: {value: '?'}}: true
    else:
      false


transform_foo = fn node, id, {partials=[], ...ctx}:
  partial = is_partial:: node

  foo_ctx = {...ctx, partials: [id, ...partials]}

  {partial, ...ctx.transform(node, foo_ctx)}


comp = fn left, right:
  match right:
    {partial: true}: right
    else: eq(left, right)


split_simple_nested = fn id_props, use_val, ctx:
  pipe id_props:
    fold [id, item], [simple, nested]=[[], []]:
      elem = match true:
        use_val:
          match item.value:
            {type: 'block', exprs: {length: 1}}:
              {exprs: [expr]} = item.value
              expr
            else:
              item.value
        else: item

      match elem:
        {type: 'array'}:
          [simple, [...nested, {elem, id}]]
        {type: 'object'}:
          [simple, [...nested, {elem, id}]]
        else:
          foo = transform_foo(elem, id, ctx)
          [[...simple, {id, elem: foo}], nested]


match_props = fn value, props, emit_result, ctx:
  [...id_props] = pipe props:
    map prop:
      id = ctx.unique_ident('p')
      [id, prop]

  decl = objectPattern(
    id_props.map(fn [id, prop]:
      [key, computed] = get_key(prop, ctx)
      objectProperty(key, id, computed)
    )
  )

  [simple, nested] = split_simple_nested(id_props, true, ctx)

  nested_block = match nested:
    {length: 0}:
      emit_result()
    else:
      blockStatement(
        nested.map(fn {elem, id}:
          match_condition(id, elem, emit_result, ctx)
        )
      )

  blockStatement([
    consts(decl, value),
    match simple:
      {length: 0}:
        nested_block
      else:
        iff(and(...simple.map(fn {elem, id}: comp(id, elem))))(
          nested_block
        )
  ])


match_obj = fn value, expr, emit_result, ctx:
  iff(not_nullish(value))(
    match_props(value, expr.exprs, emit_result, ctx)
  )


match_elems = fn value, elems, emit_result, ctx:
  [...id_elems] = pipe elems:
    map elem:
      id = ctx.unique_ident('a')
      [id, elem]

  decl = arrayPattern(id_elems.map(fn [id]: id))

  [simple, nested] = split_simple_nested(id_elems, false, ctx)

  blockStatement([
    consts(decl, value),

    iff(and(...simple.map(fn {elem, id}: comp(id, elem))))(
      match nested:
        {length: 0}:
          emit_result()
        else:
           blockStatement(
            nested.map(fn {elem, id}:
              match_condition(id, elem, emit_result, ctx)
            )
          )
    )
  ])


match_array = fn value, expr, emit_result, ctx:
  iff(is_iterable(value))(
    match_elems(value, expr.exprs, emit_result, ctx)
  )


match_simple = fn value, expr, emit_result, ctx:
  foo = transform_foo(expr, value, ctx)

  # TODO: make wrapping more clear
  {
    ...foo,
    ...iff(comp(value, foo))(
      emit_result()
    )
  }


match_condition = fn value, expr, emit_result, ctx:
  match expr:
    {type: 'object'}:
      match_obj(value, expr, emit_result, ctx)

    {type: 'array'}:
      match_array(value, expr, emit_result, ctx)

    else:
      match_simple(value, expr, emit_result, ctx)


split_condition = fn {left, right}:
  [left, right]


match_all = fn value, matches, emit_result, ctx:
  pipe matches:
    map expr:
      [condition, result] = split_condition(expr)

      match condition:
        {value: 'else'}:
          emit_result(result)
        else:
          match_condition(value, condition, fn: emit_result(result), ctx)


transform_match = fn node, ctx:
  {exprs} = node
  [inputs] = node.args

  value = ctx.unique_ident('value')
  break_lbl = ctx.unique_ident('match')

  emit_result = fn result:
    blockStatement([
      expressionStatement(ctx.transform(result)),
      breakStatement(break_lbl)
    ])

  expr_block(
    labeledStatement(break_lbl,
      blockStatement([
        consts(value, ctx.transform(inputs)),
        ...match_all(value, exprs, emit_result, ctx)
      ])
    )
  )


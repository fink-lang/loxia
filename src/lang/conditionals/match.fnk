babel_types = import '@babel/types'
{
  blockStatement, breakStatement, labeledStatement, objectPattern
  objectProperty, expressionStatement, ifStatement
  doExpression, stringLiteral, memberExpression, restElement
  identifier
} = babel_types
{length, is_empty} = import '@fink/std-lib/iter.fnk'

{and, eq, not_nullish, typof, consts} = import '../../js/types.fnk'

{get_key} = import '../literals/record.fnk'
{is_partial} = import '../partial/init.fnk'
{wrap_with_comment_loc} = import '../comments/init.fnk'
{transform} = import '../transform.fnk'



iter = fn value:
  symb = identifier 'Symbol'
  iterator = identifier 'iterator'
  symb_iter = memberExpression symb, iterator
  memberExpression value, symb_iter, true



is_iterable = fn value:
  and
    not_nullish value
    eq
      typof iter value
      stringLiteral 'function'



comp = fn id, expected, ctx:
  value_ctx = {...ctx, partial_ident: id}
  # TODO: test how deep `?` goes
  [value, {partial_ident: _, ...next_ctx}] = transform expected, value_ctx

  cond = match expected:
    is_partial ?: value
    else: eq id, value

  [cond, next_ctx]



match_props = fn props, emit_result, ctx, cond:
  [{id, prop}, ...rest] = props

  value = match prop:
    {left: {type: 'spread'}}:
      prop.left
    else:
      prop.right

  emit = match props:
    1 == length ?:
      emit_result
    else:
      fn ctx:
        match_props rest, emit_result, ctx, cond

  match_condition id, value, emit, ctx, cond



match_obj = fn value, obj, emit_result, ctx, cond:
  [...id_props] = pipe obj.exprs:
    map prop:
      id = ctx.unique_ident 'p'
      {id, prop}

  decl = objectPattern list:
    ... pipe id_props:
      map {id, prop}:
        match prop:
          {left: {type: 'spread'}}:
            restElement id
          else:
            [computed, key] = get_key prop, ctx
            objectProperty key, id, computed

  ifStatement
    not_nullish value
    match id_props:
      is_empty ?:
        emit_result ctx
      else:
        blockStatement list:
          consts decl, value
          match_props id_props, emit_result, ctx, cond



match_elems = fn elems, emit_result, ctx, cond:
  [{id, value}, ...rest] = elems

  emit = match elems:
    1 == length ?: emit_result
    else: fn ctx: match_elems rest, emit_result, ctx, cond

  match_condition id, value, emit, ctx, cond



get_array_decl = fn arr, id_elems, right, ctx:
  [...exprs] = pipe id_elems:
    map {id, value}:
      match value:
        # e.g. empty elems in [,, foo, bar]
        {type: 'empty'}:
          value

        # e.g. spread in [foo, ...bar, spam]
        {type: 'spread', right: {}}:
          ident = {type: 'ident', value: id.name}
          {...value, right: ident}

        # e.g. spread in [foo, ..., bar]
        {type: 'spread'}:
          value

        else:
          {type: 'ident', value: id.name}

  left = {type: 'list', exprs, loc: arr.loc}

  [decl, next_ctx] = transform
    dict:
      type: 'assign'
      op: '='
      left
      right: {type: 'ident', value: right.name, loc: arr.loc}
      loc: arr.loc
    ctx

  js = consts decl.left, decl.right
  [js, next_ctx]



match_array = fn value, arr, emit_result, ctx, cond:
  [...id_elems] = pipe arr.exprs:
    map expr:
      id = ctx.unique_ident 'a'
      {id, value: expr}

  [array_decl, next_ctx] = get_array_decl arr, id_elems, value, ctx

  [...filtered_id_elems] = pipe id_elems:
    filter {value}:
      match value:
        # empty elements need no matching
        {type: 'empty'}: false
        {type: 'spread', right: {}}: true
        # empty spreads need no matching
        {type: 'spread'}: false
        else: true

  result = match id_elems:
    is_empty ?:
      emit_result next_ctx
    else:
      blockStatement list:
        array_decl
        match_elems filtered_id_elems, emit_result, next_ctx, cond

  ifStatement
    is_iterable value
    result



match_simple = fn value, expr, emit_result, ctx:
  [cond, result_ctx] = comp value, expr, {...ctx, wrap: 'loc'}
  result = emit_result result_ctx
  ifStatement cond, result




match_condition = fn value, expr, emit_result, ctx, cond:
  js_expr = match expr:
    {type: 'rec'}:
      match_obj value, expr, emit_result, ctx, cond

    {type: 'list'}:
      match_array value, expr, emit_result, ctx, cond

    {type: 'spread', right: {}}:
      match_condition value, expr.right, emit_result, ctx, cond

    else:
      match_simple value, expr, emit_result, ctx

  wrap_with_comment_loc js_expr, cond



split_condition = fn {left, right}:
  [left, right]



match_all = fn value, matches, emit, ctx:
  exprs = pipe matches:
    map expr:
      match expr:
        {type: 'block', op: 'else'}:
          {op:_, ...block} = expr
          js_expr = emit block, ctx
          wrap_with_comment_loc js_expr, block
        else:
          [condition, result] = split_condition expr
          emit_result = fn ctx: emit result, ctx
          match_condition value, condition, emit_result, ctx, condition
  [exprs, ctx]



result_emitter = fn break_lbl: fn result, ctx:
  [result_js, next_ctx] = transform result, ctx
  js = blockStatement list:
    expressionStatement result_js
    breakStatement break_lbl

  js # TODO [js, next_ctx]



transform_match = fn node, ctx:
  {exprs} = node
  [inputs] = node.args

  value = ctx.unique_ident 'value'
  break_lbl = ctx.unique_ident 'match'

  emit_result = result_emitter break_lbl

  [inputs_js, next_ctx] = transform inputs, ctx
  [match_exprs, end_ctx] = match_all value, exprs, emit_result, next_ctx

  js = doExpression
    blockStatement list:
      labeledStatement
        break_lbl
        blockStatement list:
          consts value, inputs_js
          ...match_exprs

  [js, end_ctx]

{
  arrayPattern, blockStatement, breakStatement, labeledStatement, objectPattern,
  objectProperty, isObjectExpression, isArrayExpression, expressionStatement,
  identifier
} = import '@babel/types'

{
  member, str, for_of, split_last, and, eq, not_nullish, typof,
  expr_block, consts, iff
} = import '../../js/types'

{is_call, is_calling} = import '../call/call'
{is_array} = import '../literals/array'


iter = fn value:
  member(value)(member(identifier('Symbol'))(identifier('iterator')), true)


is_iterable = fn value:
  and(
    not_nullish(value),
    eq(
      typof(iter(value)), str('function')
    )
  )


split_simple_nested = fn id_props, use_val:
  pipe id_props:
    fold [id, item], [simple, nested]=[[], []]:
      elem = match true:
        use_val: item.value
        else: item

      match true:
        (isArrayExpression(elem) || isObjectExpression(elem)):
          [simple, [...nested, {id, elem}]]
        else:
          [[...simple, {id, elem}], nested]


match_props = fn value, props, emit_result, ctx:
  [...id_props] = pipe props:
    map prop:
      [ctx.unique_ident('p'), prop]

  decl = objectPattern(
    id_props.map(fn [id, prop]: objectProperty(prop.key, id))
  )

  [simple, nested] = split_simple_nested(id_props, true)

  nested_block = match nested:
    {length: 0}:
      emit_result()
    else:
      blockStatement(
        nested.map(fn {elem, id}:
          match_condition(id, elem, emit_result, ctx)
        )
      )

  blockStatement([
    consts(decl, value),
    match simple:
      {length: 0}:
        nested_block
      else:
        iff(and(...simple.map(fn {elem, id}: eq(id, elem))))(
          nested_block
        )
  ])


match_obj = fn value, expr, emit_result, ctx:
  iff(not_nullish(value))(
    match_props(value, expr.properties, emit_result, ctx)
  )


match_elems = fn value, elems, emit_result, ctx:
  [...id_elems] = pipe elems:
    map elem:
      [ctx.unique_ident('a'), elem]

  decl = arrayPattern(id_elems.map(fn [id]: id))

  [simple, nested] = split_simple_nested(id_elems, false)

  blockStatement([
    consts(decl, value),

    iff(and(...simple.map(fn {elem, id}: eq(id, elem))))(
      match nested:
        {length: 0}:
          emit_result()
        else:
           blockStatement(
            nested.map(fn {elem, id}:
              match_condition(id, elem, emit_result, ctx)
            )
          )
    )
  ])


match_array = fn value, expr, emit_result, ctx:
  iff(is_iterable(value))(
    match_elems(value, expr.elements, emit_result, ctx)
  )


match_simple = fn value, expr, emit_result:
  # TODO: make wrapping more clear
  {
    ...expr,
    ...iff(eq(value, expr))(
      emit_result()
    )
  }


match_condition = fn value, expr, emit_result, ctx:
  match true:
    isObjectExpression(expr):
      match_obj(value, expr, emit_result, ctx)

    isArrayExpression(expr):
      match_array(value, expr, emit_result, ctx)

    else:
      match_simple(value, expr, emit_result)


split_condition = fn {left, right}:
  [left, right]


match_all = fn value, matches, emit_result, ctx:
  pipe matches:
    map expr:
      [condition, result] = split_condition(expr)
      test = ctx.transform(condition)

      match condition:
        {value: 'else'}:
          emit_result(result)
        else:
          match_condition(value, test, fn: emit_result(result), ctx)


transform_match = fn node, ctx:
  {exprs} = node
  [inputs] = node.args

  value = ctx.unique_ident('value')
  break_lbl = ctx.unique_ident('match')

  emit_result = fn result:
    blockStatement([
      expressionStatement(ctx.transform(result)),
      breakStatement(break_lbl)
    ])

  expr_block(
    labeledStatement(break_lbl,
      blockStatement([
        consts(value, ctx.transform(inputs)),
        ...match_all(value, exprs, emit_result, ctx)
      ])
    )
  )


babel_types = import '@babel/types'
{
  blockStatement, breakStatement, labeledStatement, objectPattern
  objectProperty, expressionStatement, ifStatement
  doExpression, stringLiteral, memberExpression, restElement
  identifier
} = babel_types
{length, is_empty} = import '@fink/std-lib/iter.fnk'

{and, eq, not_nullish, typof, consts} = import '../../js/types.fnk'

{get_key} = import '../literals/record.fnk'
{is_partial} = import '../partial/init.fnk'
{wrap_with_comment_loc} = import '../comments/init.fnk'


iter = fn value:
  symb = identifier 'Symbol'
  iterator = identifier 'iterator'
  symb_iter = memberExpression symb, iterator
  memberExpression value, symb_iter, true


is_iterable = fn value:
  and
    not_nullish value
    eq
      typof iter value
      stringLiteral 'function'


comp = fn id, expected, {transform, ...ctx}:
  value_ctx = {...ctx, partial_ident: id}
  value = transform expected, value_ctx

  match expected:
    is_partial ?: value
    else: eq id, value


match_props = fn props, emit_result, ctx, cond:
  [{id, prop}, ...rest] = props

  value = match prop:
    {left: {type: 'spread'}}:
      prop.left
    else:
      prop.right

  emit = match props:
    1 == length ?: emit_result
    else: fn: match_props rest, emit_result, ctx, cond

  match_condition id, value, emit, ctx, cond


match_obj = fn value, obj, emit_result, ctx, cond:
  [...id_props] = pipe obj.exprs:
    map prop:
      id = ctx.unique_ident 'p'
      {id, prop}

  decl = objectPattern list:
    ... pipe id_props:
      map {id, prop}:
        match prop:
          {left: {type: 'spread'}}:
            restElement id
          else:
            [computed, key] = get_key prop, ctx
            objectProperty key, id, computed

  ifStatement
    not_nullish value
    match id_props:
      is_empty ?:
        emit_result _
      else:
        blockStatement list:
          consts decl, value
          match_props id_props, emit_result, ctx, cond



match_elems = fn elems, emit_result, ctx, cond:
  [{id, value}, ...rest] = elems

  emit = match elems:
    1 == length ?: emit_result
    else: fn: match_elems rest, emit_result, ctx, cond

  match_condition id, value, emit, ctx, cond



get_array_decl = fn arr, id_elems, right, ctx:
  [...exprs] = pipe id_elems:
    map {id, value}:
      match value:
        # e.g. empty elems in [,, foo, bar]
        {type: 'empty'}:
          value

        # e.g. spread in [foo, ...bar, spam]
        {type: 'spread', right: {}}:
          ident = {type: 'ident', value: id.name}
          {...value, right: ident}

        # e.g. spread in [foo, ..., bar]
        {type: 'spread'}:
          value

        else:
          {type: 'ident', value: id.name}

  left = {type: 'list', exprs, loc: arr.loc}

  decl = ctx.transform dict:
    type: 'assign'
    op: '='
    left
    right: {type: 'ident', value: right.name, loc: arr.loc}
    loc: arr.loc

  consts decl.left, decl.right


match_array = fn value, arr, emit_result, ctx, cond:
  [...id_elems] = pipe arr.exprs:
    map expr:
      id = ctx.unique_ident 'a'
      {id, value: expr}

  array_decl = get_array_decl arr, id_elems, value, ctx

  [...filtered_id_elems] = pipe id_elems:
    filter {value}:
      match value:
        # empty elements need no matching
        {type: 'empty'}: false
        {type: 'spread', right: {}}: true
        # empty spreads need no matching
        {type: 'spread'}: false
        else: true

  ifStatement
    is_iterable value
    match id_elems:
      is_empty ?:
        emit_result _
      else:
        blockStatement list:
          array_decl
          match_elems filtered_id_elems, emit_result, ctx, cond


match_simple = fn value, expr, emit_result, ctx:
  ifStatement
    comp value, expr, {...ctx, wrap: 'loc'}
    emit_result _


match_condition = fn value, expr, emit_result, ctx, cond:
  js_expr = match expr:
    {type: 'rec'}:
      match_obj value, expr, emit_result, ctx, cond

    {type: 'list'}:
      match_array value, expr, emit_result, ctx, cond

    {type: 'spread', right: {}}:
      match_condition value, expr.right, emit_result, ctx, cond

    else:
      match_simple value, expr, emit_result, ctx

  wrap_with_comment_loc js_expr, cond


split_condition = fn {left, right}:
  [left, right]


match_all = fn value, matches, emit, ctx:
  pipe matches:
    map expr:
      match expr:
        {type: 'block', op: 'else'}:
          {op:_, ...block} = expr
          js_expr = emit block
          wrap_with_comment_loc js_expr, block
        else:
          [condition, result] = split_condition expr
          emit_result = fn: emit result
          match_condition value, condition, emit_result, ctx, condition


transform_match = fn node, ctx:
  {exprs} = node
  [inputs] = node.args

  value = ctx.unique_ident 'value'
  break_lbl = ctx.unique_ident 'match'

  emit_result = fn result:
    blockStatement list:
      expressionStatement ctx.transform result
      breakStatement break_lbl

  doExpression
    blockStatement list:
      labeledStatement
        break_lbl
        blockStatement list:
          consts value, ctx.transform inputs
          ...match_all value, exprs, emit_result, ctx


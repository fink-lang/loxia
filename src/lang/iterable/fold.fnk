{assign, for_of, func, lets, unique_ident} = import '../../js/types.fnk'
{transform} = import '../transform.fnk'
{get_iter_helpers, transform_init} = import './common.fnk'



get_fold_result = fn node, ctx:
  [, result_arg] = node.args

  [fold_result, fold_init_ctx] = unique_ident 'fold_result', ctx

  [fold_init, result_ctx] = match result_arg:
    {type: 'assign'}:
      [value, ccc] = transform result_arg.right, fold_init_ctx
      seq:
        lets fold_result, value
        ccc
    else:
      seq:
        lets fold_result
        fold_init_ctx

  [prev_result_assign, end_ctx] = match result_arg:
    {}:
      [prev_assign, next_ctx] = transform_init
        result_arg.left, fold_result, result_ctx
      [[prev_assign], next_ctx]
    else:
      [[], result_ctx]

  [fold_result, fold_init, prev_result_assign, end_ctx]



transform_fold = fn node, ctx:
  [item_arg, _, ...acc_args] = node.args

  {
    acc_init
    item, items
    item_acc_assign
    expressions
    next_ctx
    result
  } = get_iter_helpers {...node, args: [item_arg, ...acc_args]}, ctx

  [fold_result, fold_init, prev_result_assign, end_ctx] = get_fold_result node, next_ctx


  js = func [items],
    ...acc_init
    fold_init

    for_of [item, items],
      ...item_acc_assign
      ...prev_result_assign
      ...expressions
      assign fold_result, result

    fold_result

  [js, end_ctx]

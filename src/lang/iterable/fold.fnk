{assign, for_of, func, lets, undef} = import '../../js/types.fnk'
{exprs_block} = import '../block/init.fnk'
{transform} = import '../transform.fnk'
{transform_init} = import './common.fnk'



get_acc = fn acc_arg, ctx:
  {unique_ident} = ctx

  acc = unique_ident 'accu'

  [acc_init, acc_ctx] = match acc_arg:
    {}:
      transform acc_arg.right, ctx
    else:
      [(undef _), ctx]

  [acc_assign, next_ctx] = match acc_arg:
    {}:
      [init, next_ctx] = transform_init acc_arg.left, acc, acc_ctx
      [[init], next_ctx]
    else:
      [[], acc_ctx]

  [acc, acc_init, acc_assign, next_ctx]



transform_fold = fn node, ctx:
  {unique_ident} = ctx

  [item_arg, acc_arg] = node.args
  [...expressions, last_expr] = node.exprs

  item = unique_ident 'item'
  [item_init, acc_ctx] = transform_init item_arg, item, ctx
  [acc, acc_init, acc_assign, block_ctx] = get_acc acc_arg, acc_ctx

  items = unique_ident 'items'
  [body, result_ctx] = exprs_block expressions, block_ctx
  [result, end_ctx] = transform last_expr, result_ctx

  js = func [items],
    lets acc, acc_init

    for_of [item, items],
      ...acc_assign
      item_init
      ...body
      assign acc, result
    acc

  [js, end_ctx]

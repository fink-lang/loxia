babe_types = import '@babel/types'
{conditionalExpression} = babe_types


{length} = import '@fink/std-lib/iter.fnk'

{consts, lets, assign, unique_ident, undef, eq} = import '../../js/types.fnk'
{exprs_block} = import '../block/init.fnk'
{transform} = import '../transform.fnk'



transform_with_runtime_lib = fn iter_fn, node, ctx:
  args_len = length node.args

  [use_spread, exprs] = match node.exprs:
    [..., {type: 'spread'}]:
      spread = {type: 'literal', value: 'true', loc: node.loc}
      [...exprs, last] = node.exprs
      [spread, [...exprs, last.right]]
    else:
      spread = {type: 'literal', value: 'false', loc: node.loc}
      [spread, node.exprs]

  [result, end_ctx] = transform
    rec:
      type: 'call'
      callee: {type: 'ident', value : iter_fn}
      args: seq:
        rec:
          type: 'fn'
          args: node.args
          exprs: exprs
          loc: node.loc
        {type: 'number', value: '${args_len}', loc: node.loc}
        {type: 'literal', value: 'false', loc: node.loc}
        use_spread

      loc: node.loc
    ctx
  [result, end_ctx]



transform_init = fn left, right, ctx:
  true_left = match left:
    {type: 'assign'}:
      left.left
    else:
      left

  [item_init, right_ctx] = transform
    dict:
      type: 'assign'
      op: '='
      left: true_left
      right: {type: 'ident', value: right.name, loc: left.loc}
      loc: left.loc
    ctx

  [right_js, next_ctx] = match left:
    {type: 'assign'}:
      [value, next_ctx] = transform left.right, right_ctx
      cond = conditionalExpression
        eq right, undef _
        value
        item_init.right
      [cond, next_ctx]
    else:
      [item_init.right, right_ctx]

  js = consts item_init.left, right_js
  [js, next_ctx]



unique_idents = fn names, ctx:
  names | fold name, [ids, curr_ctx]=[[], ctx]:
    [id, next_ctx] = unique_ident name, curr_ctx
    next_ids = [...ids,  id]
    [next_ids, next_ctx]



get_accs = fn node, ctx:
  [, acc_arg] = node.args
  [...exprs, last_expr] = node.exprs

  [result_expr, result_is_spread] = match last_expr:
    {type: 'spread'}:
      [last_expr.right, true]
    else:
      [last_expr, false]

  match node.args:
    2 == length ?:
      [[acc, result, next_accu], acc_init_ctx] = unique_idents
        ['accu', 'result', 'next_accu'], ctx

      [acc_init_value, init_ctx] = transform acc_arg.right, acc_init_ctx
      acc_init = lets acc, acc_init_value

      [acc_assign, acc_ctx] = transform_init acc_arg.left, acc, init_ctx

      [result_expr_val, next_ctx] = transform result_expr, acc_ctx

      result_acc_assign = consts
        {type: 'ArrayPattern', elements: [result, next_accu]}
        result_expr_val

      next_acc_assign = assign acc, next_accu

      [[acc_init], [acc_assign], exprs, result_is_spread, [result_acc_assign, next_acc_assign], result, next_ctx]

    else:
      [result, acc_ctx] = unique_ident 'result', ctx
      [result_expr_val, next_ctx] = transform result_expr, acc_ctx
      result_assign = consts result, result_expr_val
      [[], [], exprs, result_is_spread, [result_assign], result, next_ctx]



get_item = fn node, ctx:
  [item_arg] = node.args
  [item, init_ctx] = unique_ident 'item', ctx

  match item_arg:
    {type: 'empty'}:
      [item, [], init_ctx]
    {}:
      [item_init, next_ctx] = transform_init item_arg, item, init_ctx
      [item, [item_init], next_ctx]
    else:
      [item, [], init_ctx]



get_iter_helpers = fn node, ctx, input_name='items':
  [item, item_init, acc_ctx] = get_item node, ctx

  # TODO move next line into get_accs?
  [acc_init, acc_assign, exprs, result_is_spread, foo, result, items_ctx] = get_accs
    node, acc_ctx

  [items, exprs_ctx] = unique_ident input_name, items_ctx


  [expressions, next_ctx] = pipe exprs:
    exprs_block ?, exprs_ctx

    fn [exprs, result_ctx]:
      [[...exprs, ...foo], result_ctx]

  dict:
    acc_init
    item, items
    item_init
    item_acc_assign: [...item_init, ...acc_assign]
    expressions
    result
    result_is_spread
    next_ctx



{length} = import '@fink/std-lib/iter.fnk'

{consts, yields, lets, assign, unique_ident} = import '../../js/types.fnk'
{exprs_block} = import '../block/init.fnk'
{transform} = import '../transform.fnk'



transform_init = fn left, right, ctx:
  [item_init, next_ctx] = transform
    dict:
      type: 'assign'
      op: '='
      left
      right: {type: 'ident', value: right.name, loc: left.loc}
      loc: left.loc
    ctx

  js = consts item_init.left, item_init.right
  [js, next_ctx]



yield_expr = fn result, expr, ctx:
  [yield_value, is_spread] = match expr:
    {type: 'spread'}: [expr.right, true]
    else: [expr, false]

  [result_value, next_ctx] = transform yield_value, ctx

  exprs = list:
    consts result, result_value
    yields result, is_spread

  [exprs, next_ctx]



get_accs = fn node, last_expr, ctx:
  [, acc_arg] = node.args

  match node.args:
    2 == length ?:
      [acc, acc_init_ctx] = unique_ident 'accu', ctx
      [acc_init_value, init_ctx] = transform acc_arg.right, acc_init_ctx
      acc_init = lets acc, acc_init_value

      [acc_assign, acc_ctx] = transform_init acc_arg.left, acc, init_ctx

      [result_expr, acc_expr] = last_expr.exprs
      [acc_val, next_ctx] = transform acc_expr, acc_ctx
      next_acc_assign = assign acc, acc_val

      [[acc_init], [acc_assign], result_expr, [next_acc_assign], acc, next_ctx]

    else:
      [[], [], last_expr, [], false, ctx]



get_item = fn node, ctx:
  [item_arg] = node.args
  [item, init_ctx] = unique_ident 'item', ctx

  match item_arg:
    {type: 'empty'}:
      [item, [], init_ctx]
    else:
      [item_init, next_ctx] = transform_init item_arg, item, init_ctx
      [item, [item_init], next_ctx]



get_iter_helpers = fn node, ctx:
  [item, item_init, acc_ctx] = get_item node, ctx

  # TODO move next line into get_accs?
  [...exprs, last_expr] = node.exprs
  [acc_init, acc_assign, result_expr1, next_accu, accu, items_ctx] = get_accs
    node, last_expr, acc_ctx

  [items, result_ctx] = unique_ident 'items', items_ctx
  [result, exprs_ctx] = unique_ident 'result', result_ctx

  item_acc_assign = [...item_init, ...acc_assign]

  [result_expr, result_is_spread] = match result_expr1:
    {type: 'spread'}:
      [result_expr1.right, true]
    else:
      [result_expr1, false]

  [expressions, next_ctx] = pipe exprs:
    exprs_block ?, exprs_ctx

    fn [exprs, result_ctx]:
      [result_value, next_ctx] = transform result_expr, result_ctx
      result_const = consts result, result_value
      [[...exprs, result_const], next_ctx]

  dict:
    accu, acc_init
    item, items
    item_acc_assign
    expressions
    result, result_is_spread
    next_accu
    next_ctx



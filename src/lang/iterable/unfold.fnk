{whileStatement, blockStatement} = import '@babel/types'
{is_empty} = import '@fink/std-lib/iter.fnk'


{assign, generator, true_, lets} = import '../../js/types.fnk'

{block_statement} = import '../block/index.fnk'
{transform_init, yield_expr} = import './common.fnk'



loop = fn ...body:
  whileStatement
    true_ _
    blockStatement body



get_acc_exprs = fn node, next_value, ctx:
  {transform, unique_ident} = ctx

  initial = unique_ident 'initial'
  acc = unique_ident 'accu'
  [acc_arg] = node.args;

  [acc_left, acc_right] = match acc_arg:
    {type: 'assign'}: [acc_arg.left, transform acc_arg.right]
    else: [acc_arg, initial]

  acc_init = lets acc, acc_right

  acc_assign = transform_init acc_left, acc, ctx

  acc_result = assign acc, next_value
  [[initial], [acc_init], [acc_assign], [acc_result]]



get_accs = fn node, next_value, ctx:
  match node.args:
    is_empty ?:
      [[], [], [], []]
    else:
      get_acc_exprs node, next_value, ctx



transform_unfold = fn node, ctx:
  {transform, unique_ident} = ctx

  [...expressions, last_expr] = node.exprs
  result_id = unique_ident 'result'

  [result_expr, next_accu] = match last_expr:
    {type: 'group'}:
      [result_expr, acc_expr] = last_expr.exprs
      [result_expr, transform acc_expr]
    else:
      [last_expr, result_id]

  [initial, acc_init, acc_assign, acc_result] = get_accs node, next_accu, ctx

  generator 'unfold', [...initial],
    ...acc_init

    loop
      ...acc_assign

      ...pipe expressions:
        map expr: block_statement expr, ctx

      ...yield_expr result_id, result_expr, ctx

      ...acc_result

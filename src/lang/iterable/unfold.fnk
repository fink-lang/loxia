{whileStatement, blockStatement, assignmentPattern} = import '@babel/types'
{assign, generator, consts, yields, true_} = import '../../js/types'

{block_statement} = import '../block'
{transform_init} = import './init'


loop = fn ...body:
  whileStatement true_(), blockStatement body


get_acc_exprs = fn node, next_value, ctx:
  {transform, unique_ident} = ctx

  acc = unique_ident 'accu'
  [acc_arg] = node.args;

  acc_left = match acc_arg:
    {type: 'assign'}: acc_arg.left
    else: acc_arg

  acc_init = match acc_arg:
    {type: 'assign'}:
      assignmentPattern
        acc
        transform acc_arg.right
    else:
      acc

  acc_assign = transform_init acc_left, acc, ctx

  acc_result = assign acc, next_value

  [[acc_init], [acc_assign], [acc_result]]


get_accs = fn node, next_value, ctx:
  match node.args:
    {length: 0}:
      [[], [], []]
    else:
      get_acc_exprs node, next_value, ctx


yield_expr = fn result, expr, {transform}:
  [yield_value, is_spread] = match expr:
    {type: 'spread'}: [expr.right, true]
    else: [expr, false]

  list:
    consts result, transform yield_value
    yields
      result
      is_spread


transform_unfold = fn node, ctx:
  {transform, unique_ident} = ctx

  [...expressions, last_expr] = node.exprs

  result_id = unique_ident 'result'

  [result_expr, next_value] = match last_expr:
    {type: 'group'}:
      [result_expr, acc_expr] = last_expr.exprs
      [result_expr, transform acc_expr]
    else:
      [last_expr, result_id]

  [acc_init, acc_assign, acc_result] = get_accs node, next_value, ctx

  generator 'unfold', [...acc_init],
    loop
      ...acc_assign

      ...pipe expressions:
        map expr: block_statement expr, ctx

      ...yield_expr result_id, result_expr, ctx

      ...acc_result

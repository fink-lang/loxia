{count} = import '@fink/std-lib/iter.fnk'

{ident, wrap} = import '../js/types.fnk'
{var_prefix} = import '../js/identifier.fnk'

{transform_error} = import './errors.fnk'
{get_transformer} = import './context.fnk'

{add_assignment} = import './assignment/init.fnk'
{add_func} = import './func/init.fnk'
{add_conditionals} = import './conditionals/init.fnk'
{add_iterables} = import './iterable/init.fnk'
{add_call} = import './call/init.fnk'
{add_literals} = import './literals/init.fnk'
{add_spread} = import './spread/init.fnk'
{add_async} = import './async/init.fnk'
{add_logical} = import './logical/init.fnk'
{add_group} = import './group/init.fnk'
{add_module} = import './module/init.fnk'
{add_member} = import './prop-access/init.fnk'
{add_ident} = import './identifier/init.fnk'
{add_comparison} = import './comparison/init.fnk'
{add_jsx} = import './jsx/init.fnk'
{add_js_compat} = import './js-compat/init.fnk'
{add_arithmitic} = import './arithmitic/init.fnk'
{add_block} = import './block/init.fnk'
{add_partial} = import './partial/init.fnk'
{wrap_with_comment_loc} = import './comments/init.fnk'


add_transformers = fn ctx:
  pipe ctx:
    add_module
    add_ident
    add_partial
    add_literals
    add_group
    add_member
    add_logical
    add_comparison
    add_arithmitic
    add_assignment
    add_spread
    add_async
    add_func
    add_conditionals
    add_iterables
    add_call
    add_async
    add_jsx
    add_block
    add_js_compat


wrap_node = fn ctx, js_node, node:
  match ctx:
    {wrap: 'loc'}:
      wrap node, js_node
    else:
      wrap_with_comment_loc js_node, node


try_transform = fn transform, node, ctx:
  [err, js_node] = try: transform node, ctx

  match err:
    false:
      js_node
    else:
      transform_error err, node, ctx


transform_with_comments = fn transform, node, ctx:
  js_node = try_transform transform, node, ctx
  match js_node:
    {error: {}}:
      # TODO don't use mutable
      ctx.errors.push js_node
      js_node
    else:
      wrap_node ctx, js_node, node


transform_expr = fn node, ctx:
  transform_ctx = dict:
    ...ctx
    transform: fn next_node, next_ctx=transform_ctx:
      transform_expr next_node, next_ctx

  transform = get_transformer node, ctx

  match transform:
    false:
      err = transform_error 'Unknown expression.', node, ctx
      # TODO don't use mutable
      ctx.errors.push err
      err
    else:
      transform_with_comments transform, node, transform_ctx


init_ctx = fn code, filename:
  id_cntr = count 1

  ctx = dict:
    filename
    code
    errors: []
    unique_ident: fn name:
      # TODO: return ident and new ctx to make it not stateful
      {value} = id_cntr.next _
      ident '${var_prefix}${name}_${value}'

  pipe ctx:
    add_transformers


transform_ast = fn expr, code, filename, options:
  ctx = init_ctx code, filename
  js_ast = transform_expr expr, {...ctx, options}

  match js_ast:
    {error: {}}:
      {errors: ctx.errors}
    else:
      {...js_ast, errors: []}



babel_types = import '@babel/types'
{
  blockStatement, variableDeclaration, variableDeclarator, doExpression
  arrayExpression, assignmentExpression, callExpression
  memberExpression, identifier, expressionStatement, arrayPattern, restElement
  numericLiteral, awaitExpression, logicalExpression
} = babel_types
{length, is_empty} = import '@fink/std-lib/iter.fnk'

{transform_left} = import '../../js/left.fnk'
{wrap_with_comment_loc} = import '../comments/init.fnk'
{add, any} = import '../context.fnk'
{transform_value} = import '../partial/init.fnk'



has_spread_not_last = fn {left}:
  match left:
    # {type: 'list', exprs: [..., {type: 'spread'}, ..., {type: ? != 'spread'}]}:
    #   true
    {type: 'list'}:
      [...exprs, ] = left.exprs

      [spread=false] = pipe exprs:
        map {type}: type == 'spread'
        filter is_spread: is_spread

      spread
    else:
      false


transform_spread_left = fn {left}, {transform}:
  [before, middle, end] = pipe left.exprs:
    fold expr, [before=[], middle=false, end=[]]=[]:
      match expr:
        {type: 'spread', right: {}}:
          [before, expr.right, end]

        {type: 'spread'}:
          [before, {type: 'empty'}, end]

        else:
          match middle:
            false: [[...before, expr], middle, end]
            else: [before, middle, [...end, expr]]

  exprs = match before:
    is_empty ?:
      # TODO missing loc
      [middle, {type: 'list', exprs: end}]
    else:
      # TODO missing loc
      [{type: 'list', exprs: before}, middle, {type: 'list', exprs: end}]

  transform_left transform {...left, exprs}


slice = fn items, start, end=false:
  start_num = numericLiteral start

  start_end = match end:
    false:
      [start_num]
    else:
      end_num = numericLiteral end
      [start_num, end_num]

  callExpression
    memberExpression
      items
      identifier 'slice'
    start_end



transform_spread_right = fn expr, ctx:
  {left, right} = expr
  items = ctx.unique_ident 'items'
  # TODO: wrap declarator?
  items_init = wrap_with_comment_loc
    variableDeclaration
      'const'
      list:
        variableDeclarator
          arrayPattern [restElement items]
          transform_value right, ctx
    left

  len = (length left.exprs) - 1
  [[idx]] = pipe left.exprs:
    map expr, idx=0:
      ([idx, expr], idx + 1)
    filter [, {type}]:
      type == 'spread'

  slices = list:
    slice items, idx, idx - len
    slice items, idx - len

  result_items = match idx:
    0: slices
    else: [items, ...slices]

  result = expressionStatement
    arrayExpression result_items

  doExpression
    wrap_with_comment_loc
      blockStatement [items_init, result]
      left



has_await = fn node:
  match node:
    {left: {type: 'list', exprs: [{op: 'await'}]}}:
      true
    else:
      false



transform_await_left = fn node, ctx:
  {left: {exprs: [{right: expr}, ...rest_exprs], ...rest_left}} = node
  left = {...rest_left, exprs: [expr, ...rest_exprs]}
  transform_left ctx.transform left



transform_await_right = fn expr, ctx:
  {left, right} = expr
  items = ctx.unique_ident 'items'
  iter = ctx.unique_ident 'iter'

  items_init = wrap_with_comment_loc
    variableDeclaration
      'const'
      list:
        variableDeclarator
          items
          transform_value right, ctx
    right

  iter_init = wrap_with_comment_loc
    variableDeclaration
      'const'
      list:
        variableDeclarator
          iter
          callExpression
            memberExpression
              logicalExpression
                '||'
                memberExpression
                  items
                  memberExpression
                    identifier 'Symbol'
                    identifier 'asyncIterator'
                  true
                memberExpression
                  items
                  memberExpression
                    identifier 'Symbol'
                    identifier 'iterator'
                  true
              identifier 'call'
            [items]
    right

  [...right_exprs] = pipe left.exprs:
    map expr:
      wrap_with_comment_loc
        memberExpression
          awaitExpression
            callExpression
              memberExpression
                iter
                identifier 'next'
              []
          identifier 'value'
        expr


  doExpression
    wrap_with_comment_loc
      blockStatement list:
        items_init
        iter_init
        expressionStatement
          arrayExpression right_exprs
      right



transform_assign = fn node, ctx:
  match node:
    has_await ?:
      left = transform_await_left node, ctx
      right = transform_await_right node, ctx
      assignmentExpression '=', left, right

    has_spread_not_last ?:
      left = transform_spread_left node, ctx
      right = transform_spread_right node, ctx
      assignmentExpression '=', left, right

    else:
      left = transform_left ctx.transform node.left
      right = transform_value node.right, ctx
      assignmentExpression '=', left, right



add_assignment = fn ctx:
  pipe ctx:
    add any, '=', transform_assign


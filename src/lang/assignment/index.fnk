{
  blockStatement, variableDeclaration, variableDeclarator, doExpression
  arrayExpression, assignmentExpression, callExpression
  memberExpression, identifier, expressionStatement, arrayPattern, restElement
  numericLiteral
} = import '@babel/types'

{transform_left} = import '../../js/left'
{add, any} = import '../context'
{transform_value} = import '../partial'


is_spread_not_last = fn {left}:
  match left:
    {type: 'array', exprs: {length: ? > 1}}:
      idx = left.exprs.findIndex fn expr:
        match expr:
          {type: 'spread'}: true
          else: false

      idx > -1 && idx < left.exprs.length - 1
    else:
      false


transform_spread_left = fn {left}, {transform}:
  [before, middle, end] = pipe left.exprs:
    fold expr, [before=[], middle=false, end=[]]=[]:
      match expr:
        {type: 'spread', right: {}}:
          [before, expr.right, end]

        {type: 'spread'}:
          [before, null, end]

        else:
          match middle:
            false: [[...before, expr], middle, end]
            else: [before, middle, [...end, expr]]

  exprs = match before:
    {length: 0}:
      # TODO missing loc
      [middle, {type: 'array', exprs: end}]
    else:
      # TODO missing loc
      [{type: 'array', exprs: before}, middle, {type: 'array', exprs: end}]

  transform_left transform {...left, exprs}


slice = fn items, start, end=false:
  start_num = numericLiteral start

  start_end = match end:
    false:
      [start_num]
    else:
      end_num = numericLiteral end
      [start_num, end_num]

  callExpression
    memberExpression
      items
      identifier 'slice'
    start_end


transform_spread_right = fn {left, right}, ctx:
  items = ctx.unique_ident 'items'
  items_init = variableDeclaration
    'const'
    list:
      variableDeclarator
        arrayPattern [restElement items]
        transform_value right, ctx

  len = left.exprs.length - 1
  idx = left.exprs.findIndex fn expr:
    match expr:
      {type: 'spread'}: true
      else: false

  result_items = match idx:
    0: list:
      slice items, idx, idx - len
      slice items, idx - len

    else: list:
      items
      slice items, idx, idx - len
      slice items, idx - len

  result = expressionStatement
    arrayExpression result_items

  doExpression
    blockStatement [items_init, result]


transform_assign = fn node, ctx:
  match node:
    is_spread_not_last ?:
      left = transform_spread_left node, ctx
      right = transform_spread_right node, ctx
      assignmentExpression '=', left, right

    else:
      left = transform_left ctx.transform node.left
      right = transform_value node.right, ctx
      # wrap with loc and comment?
      assignmentExpression '=', left, right


add_assignment = fn ctx:
  pipe ctx:
    add any, '=', transform_assign


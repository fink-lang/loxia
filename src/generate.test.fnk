{skip, describe, it, expect, to_equal, to_match_snapshot} = import '@fink/jest/test.fnk'
{slice} = import '@fink/std-lib/str.fnk'

{generate} = import './generate.fnk'
{fink2js, fink2js_sm} = import './testing/generate.fnk'



describe 'module types', fn:
  code = "
    import 'foobar'
    foo = import 'shrub'
    {bar: spam, ni} = import 'ni'

    # reserved words import
    {default: dflt, if} = import 'es6-module'

    shrub = ni
    # reserved export
    case = ni

    default = shrub
    out = [dflt, if, spam, ni, foo]
    "

  it 'compiles to mjs', fn:
    expect
      fink2js code,  {module_type: 'mjs'}
      to_match_snapshot


  it 'compiles to cjs', fn:
    expect
      fink2js code, {module_type: 'cjs'}
      to_match_snapshot



describe 'source maps', fn:
  code = "
    nanu = 345
    foo = {bar: 12345, 'spam ni': nanu, nanu}
    bar = 'foo'
    ham = 'foo: \${foo} bar:\${bar}'
    el = <Foo>bar {123} <div foo=134 bar spam=nanu></div></Foo>
    ni = spam + foo-bar
    a = [1, 'ni']
    [b, c] = a
    out = [a, b, c]
    func = fn x, y:
      x + y + b
    y = func bar, a, b
  "
  js = fink2js_sm code

  it 'compiles to mjs', fn:
    expect
      js
      to_match_snapshot

  it 'compiles to mjs', fn:
    expect
      fink2js_sm "
        remove_unused = fn [expr=false, ...exprs], ctx, out:
          match expr:
            false:
              [out, ctx]

            [? in ['mod', 'imp', 'af', 'ac', 'cc', 'cif', 'cf']]:
              remove_unused exprs, ctx, [expr, ...out]

            [, , [is_unused ?, ctx]]:
              args = get_ref_args expr
              next_ctx = dec_refs args, ctx
              remove_unused exprs, next_ctx, out

            [? in ['fn', 'fnr', 'cn']]:
              [op, [args, body], ...rest] = expr
              rbody = reverse body
              [obody, next_ctx] = remove_unused rbody, ctx, []
              oexpr = [op, [args, obody], ...rest]
              remove_unused exprs, next_ctx, [oexpr, ...out]

            else:
              remove_unused exprs, ctx, [expr, ...out]
      "
      to_match_snapshot




describe 'errors', fn:
  it 'handles parse errors', fn:
    {errors: [{error}]} = fink2js '
      foo = ['

    expect
      error
      to_equal '
        test.fnk:1:7
        1| foo = [
                  ^

        Expected `,` or indented(>=1) new line or `]`.
        '

  skip.it 'errors with code snippet', fn:
    {errors: [{message}]} = fink2js '
      foo = bar
      123 = foo
      shrub = ni'

    expect
      message
      to_equal '
        test.fnk:2:0
        1| foo = bar
        2| 123 = foo
           ^
        3| shrub = ni

        Unable to transform `assign =`.

        TypeError: Property left of AssignmentExpression expected node to be of a type ["LVal"] but instead got "NumericLiteral"
        '

  it 'errors with bad babel options', fn:
    {errors: [{message}]} = fink2js
      'foo = bar'
      {babel: {foobar: 'spam'}}

    expect
      slice message, 0, 24
      to_equal 'Unknown option: .foobar.'


  it 'errors when provided with unknown tokens', fn:
    {errors: [{message}]} = generate
      rec:
        type: 'test'
        op: 'foobar'
        loc: rec:
          start: {pos: 0, line: 1, column: 0}
          end: {pos: 9, line: 1, column: 9}

      'test.fnk', 'foobar'

    expect
      message
      to_equal '
        test.fnk:1:0
        1| foobar
           ^

        Unable to transform `test foobar`.

        Unknown expression.
        '
